{
  "timestamp": "20250801_155411",
  "test_type": "mutation_testing",
  "metadata": {
    "task_id": "HumanEval/119",
    "timestamp": "20250801_155411",
    "tester_version": "1.0",
    "total_operators_tested": 13,
    "operators_with_errors": 0
  },
  "summary": {
    "original_passes": true,
    "total_mutations": 42,
    "killed_mutations": 39,
    "mutation_score": 0.9285714285714286,
    "survival_rate": 0.0714285714285714
  },
  "detailed_results": {
    "task_id": "HumanEval/119",
    "dataset_type": "plus",
    "original_passes": true,
    "total_mutations": 42,
    "killed_mutations": 39,
    "mutation_score": 0.9285714285714286,
    "mutation_results": {
      "NumberReplacer": {
        "total_mutations": 10,
        "killed_mutations": 10,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 1\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 1\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpr5w4cf8u.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpr5w4cf8u.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr5w4cf8u.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:02.445577",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = -1\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = -1\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmprt_2lz53.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmprt_2lz53.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprt_2lz53.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:02.601149",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 2 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 2 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp_le9h9c9.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp_le9h9c9.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_le9h9c9.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:02.777326",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 0 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 0 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpc1x4_iy8.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpc1x4_iy8.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc1x4_iy8.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:02.950836",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 2\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 2\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpr9qrwh2u.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpr9qrwh2u.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr9qrwh2u.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:03.140519",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 5,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 0\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 0\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpxqx9x7ij.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpxqx9x7ij.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxqx9x7ij.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:03.331980",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 6,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 1:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 1:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp0_bc9uzz.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp0_bc9uzz.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0_bc9uzz.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:03.548547",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 7,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < -1:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < -1:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp5hzo3i33.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp5hzo3i33.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5hzo3i33.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:03.778620",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 8,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return 1\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return 1\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpy9hy72n3.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpy9hy72n3.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpy9hy72n3.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:03.984315",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 9,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return -1\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return -1\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmprwx7ccdq.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmprwx7ccdq.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprwx7ccdq.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:04.161199",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 20,
        "mutations_tested": 10
      },
      "Add->Sub": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt - 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt - 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp9v1jfzyn.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp9v1jfzyn.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9v1jfzyn.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:04.340399",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] - lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] - lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp7fz6ba89.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp7fz6ba89.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n              ~~~~~~~~~^^^^^^\n  File \"/tmp/tmp7fz6ba89.py\", line 40, in match_parens\n    return 'Yes' if valid_parens(lst[0] - lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'\n                                 ~~~~~~~^~~~~~~~\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n",
            "timestamp": "2025-08-01T15:54:04.549983",
            "status": "BROKEN",
            "reason": "code_error"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] - lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] - lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpi6wsha7l.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpi6wsha7l.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n              ~~~~~~~~~^^^^^^\n  File \"/tmp/tmpi6wsha7l.py\", line 40, in match_parens\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] - lst[0]) else 'No'\n                                                                  ~~~~~~~^~~~~~~~\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n",
            "timestamp": "2025-08-01T15:54:04.796445",
            "status": "BROKEN",
            "reason": "code_error"
          }
        ],
        "mutation_count_available": 3,
        "mutations_tested": 3
      },
      "Sub->Add": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt + 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt + 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpobgbl9v2.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpobgbl9v2.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpobgbl9v2.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:05.015982",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Eq->NotEq": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch != '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch != '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpykid6ew_.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpykid6ew_.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpykid6ew_.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:05.247316",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt != 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt != 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpk2bogj3d.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpk2bogj3d.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk2bogj3d.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:05.453792",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "Lt->Gt": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt > 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt > 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmphj0ibj8l.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmphj0ibj8l.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphj0ibj8l.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:05.645626",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Or->And": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) and valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) and valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp0fpyn0so.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp0fpyn0so.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0fpyn0so.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:05.863157",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Remove ReturnValue": {
        "total_mutations": 3,
        "killed_mutations": 2,
        "survival_rate": 0.3333333333333333,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:54:06.086539",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp96_8szpj.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp96_8szpj.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp96_8szpj.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:06.319953",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpw3dly3x8.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpw3dly3x8.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw3dly3x8.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:06.536642",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 3,
        "mutations_tested": 3
      },
      "False->True": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return True\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return True\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpa11pnrvm.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpa11pnrvm.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa11pnrvm.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:06.739587",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Zero->One": {
        "total_mutations": 6,
        "killed_mutations": 6,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 1\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 1\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp2rke43f9.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp2rke43f9.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2rke43f9.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:06.902878",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 1:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 1:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpmuzce7jo.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpmuzce7jo.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmuzce7jo.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:07.084247",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return 1\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return 1\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp9aeuifjm.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp9aeuifjm.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9aeuifjm.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:07.302558",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 1\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 1\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmptus5kbdp.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmptus5kbdp.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptus5kbdp.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:07.494628",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[1] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[1] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp6r6tbpm1.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp6r6tbpm1.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6r6tbpm1.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:07.706169",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 5,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[1]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[1]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpvunsle37.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpvunsle37.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvunsle37.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:07.900760",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 6,
        "mutations_tested": 6
      },
      "One->Zero": {
        "total_mutations": 4,
        "killed_mutations": 4,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 0 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 0 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp1ynpdq47.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp1ynpdq47.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1ynpdq47.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:08.085867",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 0\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 0\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpp2zn48uz.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpp2zn48uz.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp2zn48uz.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:08.270216",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[0]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[0]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpfzcf829d.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzcf829d.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzcf829d.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:08.527235",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[0] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[0] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp18c4ywsw.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp18c4ywsw.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp18c4ywsw.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:08.736945",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 4,
        "mutations_tested": 4
      },
      "String->Empty": {
        "total_mutations": 4,
        "killed_mutations": 3,
        "survival_rate": 0.25,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:54:08.958655",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpgfo9osqf.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpgfo9osqf.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgfo9osqf.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:09.170279",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return '' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return '' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp4marveqh.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp4marveqh.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4marveqh.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:09.403618",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else ''",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else ''",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp0htb4ckf.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp0htb4ckf.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0htb4ckf.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:09.633534",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 4,
        "mutations_tested": 4
      },
      "String->X": {
        "total_mutations": 4,
        "killed_mutations": 3,
        "survival_rate": 0.25,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"X\"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"X\"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:54:09.821761",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == 'X' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == 'X' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpdheru3g1.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpdheru3g1.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdheru3g1.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:10.039181",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'X' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'X' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpjocd5a7o.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpjocd5a7o.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjocd5a7o.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:10.224684",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'X'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'X'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp37uf6lok.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp37uf6lok.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp37uf6lok.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:10.397747",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 4,
        "mutations_tested": 4
      },
      "Ternary Condition": {
        "total_mutations": 4,
        "killed_mutations": 4,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if True else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if True else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpqhozrygi.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpqhozrygi.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqhozrygi.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:10.570792",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if False else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if False else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp_jrfkud7.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp_jrfkud7.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_jrfkud7.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:10.772428",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if True else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if True else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpgr1_vben.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmpgr1_vben.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgr1_vben.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:10.952418",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
            "mutated_code": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if False else 'No'",
            "mutated_complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\ndef match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == '(' else cnt - 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n    return 'Yes' if False else 'No'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp_zmokjqy.py\", line 78, in <module>\n    check(match_parens)\n    ~~~~~^^^^^^^^^^^^^^\n  File \"/tmp/tmp_zmokjqy.py\", line 72, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_zmokjqy.py\", line 65, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:54:11.129240",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 4,
        "mutations_tested": 4
      }
    },
    "problem_info": {
      "prompt": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
      "canonical_solution": "\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n",
      "test_code": "\n\nimport numpy as np\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\ndef assertion(out, exp, atol):\n    exact_match = out == exp\n\n    if atol == 0 and is_floats(exp):\n        atol = 1e-6\n    if not exact_match and atol != 0:\n        assert np.allclose(out, exp, rtol=1e-07, atol=atol)\n    else:\n        assert exact_match\n\n\ndef check(candidate):\n    inputs = [[['()(', ')']], [[')', ')']], [['(()(())', '())())']], [[')())', '(()()(']], [['(())))', '(()())((']], [['()', '())']], [['(()(', '()))()']], [['((((', '((())']], [[')(()', '(()(']], [[')(', ')(']], [['(', ')']], [[')', '(']], [['(', '(']], [['))', '))']], [['(', '()())(']], [['()()', '()()()']], [['(())', ')()(']], [['()()', '))']], [['((', '))']], [['(((', ')))']], [['()', ')()(']], [['())(', '()']], [['(', '((']], [['()()()()', '))']], [['()()()(', '))']], [['()()()(()())', '))']], [['', '(']], [['()()(()()()()()', '))']], [['()()()(', ')()()()(()()))']], [[')()()()(', ')()()()(()()))']], [[')()(', ')()(']], [[')()(', ')())()()()(']], [[')()()()(()()))', '(']], [['()(()()()(()()))()(()())', '))']], [['((', '(']], [['()(()()()(()()))()(()())', '()(()(()()(()()))()(()())']], [['())(', '((']], [['()()', '()()()()()()()']], [['())))(', '((']], [['', '((']], [['(((', '(']], [['()(()()()()))()(()())', '))']], [['())(', '())']], [['()()', '()()']], [['((', '((']], [[')()(', ')()))()()()(']], [['(())(', '()']], [['()()()(', '))())']], [['))())', '((']], [['', '']], [['(', '()(']], [['()())((((', ')))']], [['((', ')()(']], [['()(()()()(()()))()(()())', '()(()(()()(()()())(()())']], [['((', '()())(']], [['(())(((', '))']], [['(((', ')']], [['()()()()()()()', '']], [['()()((', ')()(']], [['((', ')()))()()()(']], [['((', '']], [['(())', ')))()))(']], [['()()(())())', '))())']], [['()()()()()()()()()()()', '()()()()()()()']], [['())))(', ')()()()(()()))']], [[')()()()(()()))', '((']], [['()())(())(', '((']], [['()()()(()())', ')()()()())']], [['((', '()()()()(()()))(']], [['())(', '())(']], [['((((', '(']], [['(())', '()())()))()()((']], [['()())((((', '))))']], [['', '()()(()()()()()']], [['()()()((', '))())']], [['()())(())(', ')()()()(()()))']], [[')()()()(()()))', '())))(']], [['', '()']], [[')()))()))))()()(', ')()))()()()(']], [[')()(', ')()()()(()()))']], [['()(()()()()))()(()())', ')()()()())']], [['())(', ')()']], [['((', '()()(']], [[')()))()))))()()(', ')()))()(()((())(']], [['(())(', '()())(())((()']], [['(()(', '()']], [['(())(((', '()()()()()()()()()()()']], [['()()()()()()()', '))))']], [['()()()((', '))(']], [['', '())']], [[')())()()()(', '()']], [['()', '()']], [['((', '()()()()()()()()()(']], [['((((', ')()))()))))()()(']], [['(())(', '()()()()()()()()())(())((()']], [['((', '()())()))()()((']], [['()())(()))(', ')()()()(()()))']], [['()(((', '()()((']], [[')()(', ')()))()()(()(']], [[')()))()()(()((((', '(']], [['())()()()()(', '()']], [['()()()(', ')()))()()(()((((']], [['()()()))))((', '))(']], [['()(()()()()))()(()())', '((']], [['()()((', '()()(']], [['(())', '(((']], [['(()(()()(()()())', ')))()))(']], [['()(()()()(()()))()(()())', '((((']], [['(((', '()()(']], [['()()()()(()()))(', '(()))(((']], [['())))(', '(']], [['(', '()(()))()']], [['(((((((', '((((())))))))']], [['()(((', '))))']], [[')(()()', '((((((())))']], [['())()()(', ')))))(']], [['(((())))', '()']], [[')()()(', '(()))']], [[')))))', '(((((']], [['((', ')))))(((']], [['(()(', '))))']], [['())()()(', ')))(()()))(']], [['(((())))', '(((())))']], [['())()()(', ')))))(((']], [[')()())(', '(()))']], [['(((())))', '(()))']], [['())()())))))(', ')))(()()))(']], [['((((())))))))', '))))']], [['()(((', ')))))']], [['((((())))))))', '((((()))))((((()))))))))))']], [['(', ')))))(((']], [['((()(', '))))']], [['((((())))))))', '((((()))))(())']], [['(', ')))))']], [['((((())))))))', '((((()))))((((())))))))))))))((())']], [[')))(()()))(', ')))(()()))(']], [['((((((())))', '))))']], [[')))(', ')))(()())))(']], [['((()((', '))))']], [['((((())))))))', '((((()))))((((()))))))))))))))((())']], [['(((())))))))((()', '(((())))']], [['((((((())())', '))))']], [[')))))(((', '())()()(']], [['()(((', '((((()))))(())']], [['((((())))))))', '((((()))))(()))(()())))()))))))))))((())']], [['(()(', ')))(()()))(']], [['(((((', '()']], [[')()()(', '(']], [['()(((', '((((())))))))))(())']], [['((((()((((((()))))))', '))))']], [['((((()(()))))))', ')))))']], [[')()(((', '((((()))))(())']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', '))))']], [['(((()()))', '(((())))']], [['((((()))))(((((())))))))))))))((())', '((((()))))((((())))))))))))))((())']], [['((((()))))(((((())))))))))))))((())', '()(()))()']], [['()', '(((())))']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', ')))(()())))(']], [[')))))(((', '))))']], [['(()()()()(', '(()))']], [[')))(()()))(((((()))))(((((())))))))))))))((())', ')))(()())))(']], [['(()))))(', '))))']], [[')((((()((((((()))))))))))', '(((((']], [['())()()(', '())()()(']], [['(', '()((((()((()']], [['((((()))))', '((((()))))((((()))))))))))))))((())']], [['(((((((', '(']], [['())()()(', '(()(']], [['()((()))(', '((((()))))(())']], [['())()())))))(', '()()))(']], [[')()(', '(()))']], [['(()(', '))))()(((']], [['()((()))(())()()(', '(()(']], [['(((((((', '((']], [['(()(', '((']], [['()(((', '()(((']], [['((', '()((((()((()']], [[')))))', '((()(()()((']], [['((((((()()))((((((()((((((()))))))(())))', '((((((()()))(((())))']], [['())()()))))', '()()))(']], [['()((()))(', '(((((((']], [[')))(((())))()))(', ')))(()()))(']], [['(((((((', '((((()))))(())']], [[')()(', '()']], [[')(()()', ')))))(((']], [['(()(', ')))))']], [['((()((()))()()()()(', '(()))']], [[')))))', ')))))']], [[')()(((', ')))(()()))(']], [['(()((', ')))(()()))(']], [['((((((())))', ')))))']], [['())()()))))', '((((())))))))']], [['())()()))(()()))()(', ')))))(((']], [['))))', '((((()))))((((()))))))))))))))((())']], [[')))))', '()((()))(']], [['(()((', ')()())(']], [['(()(', '(()))']], [[')(()()', ')(()()']], [[')))))((', ')))))(((']], [[')()())(', '()((()))(())()()(']], [[')))(()())))(', '))))']], [['((((()))))((((())))))))))))))((())', '(()))']], [[')))))', '))))']], [[')))))((', '(()))))(']], [['((((())))))))', '']], [['())()())))()())())', '((((())))))))']], [['))))', '((((()))))(())']], [['(((((', '((((()))))(())']], [['((()((()))()()()()(', '()((((()((()']], [[')()(', '(())))']], [['((()((', ')))(()()))(']], [['()(((', '()((((((())))))))))(())(']], [['()((()))(', '(((((((()))))(((((())))))))))))))((())((((']], [['()(()))()', '))))']], [[')))))', '((((()((((((()))))))']], [['((((()))))(())', '((((()))))(())']], [['()))))()(((', '()(((']], [['()(((', ')()(((']], [['())(()()(', '(()(']], [[')))))', '))(()))))))']], [['((((()))))', '(()))']], [[')()(', '((()(']], [['()((()))(', '((((()()))((((((']], [['()()))(', '()']], [['(()(', '(((']], [[')))))((', '()()))(']], [['()))(((())))()))((()(()()((', '((()(()()((']], [['(()(((((()((((((()))))))', '(()(']], [['))(()))))))', '))(()))))))']], [['()))()())))))(', '())()())))))(']], [['()((((', '()((((((())))))))))(())(']], [['((((((', '()']], [['()))()())))))(', '()(((']], [[')))))', '()(((']], [['((((()))))))))))(())', '())()())))))(']], [['())()()))))', '))))']], [[')))(', '(()((']], [['(((((((())))', ')))))']], [['((((()((((((()))))))', '))())))))()((()']], [['(((((', ')()']], [[')))))(((', '())()()))(()()))()(']], [['())()()))))', '((((()))))((((()))))))))))))))((())']], [['()(((', '(())))']], [[')()(', '((())(']], [['()))))()(((', ')))(()()))(']], [['())()())))(((()())))', '))))']], [[')))))((', '))))))(((']], [['()(((', ')((((()))']], [[')()()(', ')))(()()))(']], [['))))', '())()())))))(']], [['))))', '())()()))))']], [['((((((()()))((((((()((((((()))))))(())))', '((((((()())(((((((()))))(((())))']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', '((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))']], [[')()()(', ')()()(']], [[')))(()())))(', '()(()))()']], [['((()((', ')))))(((']], [['))))', ')))))']], [['((((()((((((()))))))', ')))))']], [['())()()))))', '((((()))))((((()))))))))))))))((()())()()))(()()))()(']], [['((((((())())', ')))))(']], [['()))))()(((', '))()((((()((())))']], [['(((((((', '(((((((']], [['()()))(', '()()))(']], [['())()()(', '((((()))))((((()))))))))))))))((())']], [['(((((((', '((((()))))(()))))((())']], [['()(((', '((()(']], [['((((()))))(((((())))))))))))))((())', '((()((()))()()()()(']], [[')()()', '((((((())))']], [['()(((', ')((((()']], [['()((()))(', '((((()())()((((((']], [['((((())))))))', '((((()))))(()))(()())))())))))))()(()))())))((())']], [['()))))()(((', ')))(((())))()))(']], [['()))()())))))(', '(()((((((())))))))))(())()(((']], [['((((()))))(())', '(()((()))))(())']], [[')))(((((()))))())(', ')))(()()))(']], [['((((((()()))((((((()((((((()))))))(())))', '((((((()())(((((((())))((((()))))))))))(())((())))']], [['()))()())))))(', '()))(((((()))))())((((']], [['())()()))(()()))()(', '((((((()())(((((((()))))(((())))']], [['(((((()))))((((()))))))))))))))((())', '(((((()))))((((()))))))))))))))((())']], [['()(()))()', '(()))))']], [['()((()))(', '(((((((((((((())))']], [['()(((())))))))', '((((())))))))']], [[')))))(((', ')))))(((']], [['()))()())))))(', '()))()())))))(']], [['((()(()(((()()((', '((()(()()((']], [['((((()))))(()))(()())))())))))))()(()))())))((())()))()())))))(', '()(((']], [['()((()))(', '((((())))']], [[')()(((', '((((((((((()))))(((((())))))))))))))((())(((((()))))(())']], [['()(((((()))))((((())))))))))))))((())((', ')()(((']], [[')((((()', ')((((()']], [[')()(', '()((((()))))((((()))))))))))']], [['((((((', '(((((']], [['))))', '(()(']], [['())()()(', '((((()((((((()))))))']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', ')))(()())))((((((((']], [[')))(()())))(', ')))((()((()))()()()()()']], [['))(()))))((((()))))(()))(()())))())))))))()(()))())))((())()))()())))))())', '))(()))))))']], [[')))(()()))))((((((((', ')))(()()))(']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', '((((((((()))))(())(((()))))))']], [['((()(', '(()))']], [['())()())())))(', ')))(()()))(']], [['()))(((())))()))((()(()()((', ')))))']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', ')))(()())))(((((((((']], [['((', '(((']], [['(()))))(', '))(((((((())))']], [['(()(((((()(((((((()))))))', '(()(']], [[')))(()()))((((())((())', ')))(()())))(']], [['))()(', '(()))']], [[')))))', '(()(']], [[')()())()())))(((()())))(((', '((((()))))(())']], [['((((()()))((((((', '()(()))()']], [['((((())))))))', '((((())))))))']], [['()(((', '((((())))))))))((()(((((()((((((()))))))())']], [['((((((())))', ')))(()())))(']], [['()()))', '()()))(']], [['((((((())))', '))']], [['((((((()())(((((((())))((((()))))))))))(())((())))', '((((()))))((((()))))))))))))))((())']], [['())()()(', '((((()(((((((()))))))']], [['))))', '((()((']], [[')))())))))()((()((((()', ')((((()']], [['((((()()))((((((', '((((()))))((((())))))))))))))((())']], [['(()((((((())))))))))(())()(((', '())()()(']], [['(())))', '(())))']], [[')()()(', ')))))']], [['())))()())))))(', '()))()())))))(']], [['((((((((()))()))))))', ')))(()())))((((((((']], [['()))()(', ')))))(((']], [[')()((((', '((((()))))(())']], [['()((())))))))((', '(((((((()))))((((((())))))))))))))((())((((']], [['())()()))))', '))()((((()((())))']], [['()))()(', ')((((()']], [['()(((((())))', '((((()(((((((()))))))((((((())))']], [[')()()(', ')()(((']], [['())()())))(((()())))', '())()())))(((()())))']], [['())()()))))', ')((((()))))(((((()())))))(']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((((()()))(((())))((((()))))))', '(()((((((())))))))))(())()(((']], [['))(()))))((((()))))(()))(()())))())))))))()(()))())))((()))()))()())))))())', '))(())))))()']], [[')))(()()))))(((((((()(()()', '((((((())))']], [['()((((((())))))))))(())(', '((((()()))((((((']], [['(()))))(', '))(()))))((((()))))(()))(()())))())))))))()(()))())))((()))()))()())))))())']], [[')(()()', '((((())))))))']], [['((()(((()))()()()()(', '(()))']], [['())()()))))', ')((((()))))(((((()())))(']], [['((()((', '']], [[')))))))))))(((()(())', '())()())))))(']], [['()(((()))(', '((((()())()((((((']], [['))()(((', '))()(((']], [['((()(((()))()()()()())()()(', '(()))']], [['()(((()))(', '(((((()())(()((((((']], [['(()(', '((((()))))(()))(()())))())))))))()(()))())))((())']], [['())()()))))', '((((()))))(((((()()()()(()))))))))))))))((())']], [['))(()))))))', '((((()(((((((()))))))((((((())))']], [['()(((((()))))((((())))))))))))))((())((', ')()((']], [['))))))(((', '))))))(((']], [['())()()))))', ')))(()())))(']], [['()()))', '(((((()))))(()))))((()))()))(']], [['((((()))))(()))(()())))())))))))))(()))))))()(()))())))((())()))()())))))(', '()(((']], [[')()(', '(((((()))))))))))(())())))']], [['((((()((((((())))))))', '))))']], [['((((((((()))))(()))((()())))()))))))))))((())()((((((()))))))', '((((((((()))))(()))(()())))()))))))))))((())()((((((())(())))))))']], [['())())()))))', '())()()))))']], [['((((((()()))(((())))', '((((((()))()']], [['()(((', ')(()((()']], [['((((()))))(())', '(()((())()))(())']], [['((', '()(()))()']], [['()', '(((()))))(()()))())']], [['((()(', ')))))']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((((()()))(((())))((((()))))))', '(((((()))))))))))(())())))']], [['())()()))))', ')))))']], [['())()())))))(()(((', '()(((']], [['(((())))', '(()((())()))(())']], [['((()(((()))()()()()(', '(()(((((()())(()(((((())']], [[')()(', '((((()))))(()))']], [['((((((', '()))(()()))))(((((((()(()())']], [['()))()()(', ')))(()()))(']], [['(()((', '(()(((((()((((((()))))))']], [[')()', ')))))(((']], [['((((()))))(((((())))))))))))))((())', '((()((()))()))(((((()))))())((((()()(']], [['((((((((()))))(()))(()())))()))))))))))((())()((((((()))))))', '(((()()))']], [['((()()()()(', '(()))']], [[')))(()()))))))((()((()))()()()()()(', '()(()))()']], [['()(((', '(()(']], [[')))))', '()((()))(()))(((())))()))((()(()()((']], [['))((((((((()))))(()))((()())))()))))))))))((())()((((((())))))))))', '))((((((((()))))(()))((()())))()))))))))))((())()((((((())))))))))']], [['((((()))))))))((()((()))()()()()()))', '((((()))))(()))(()())))())))))))()(()))())))((())']], [['((', '(()(']], [['())()))()())))))()()())))))(', '))))']], [['((((((((((()))))(((((())))))))))))))((())(((((()))))(())', '((()((']], [['((((()()))((((((', '((((((((()))))(()))(()())))()))))))))))((())()((((((())(())))))))']], [['()(((', ')(()(((()']], [['((((((())))', '))))))(())(()())))(']], [['(()))))(', ')))((((())))))))))(()))']], [['))(()))))))', '((((()(((((((())))()))((((((())))(((()))))(()()))())']], [[')(((((', ')()((((']], [[')()()))())))))()((()((((())(', ')()(((']], [[')((((()))))(((((()())))))(', ')(((()()']], [['()((((((((()))())))))))))))', '())()()))))']], [['((()(', '(()()()()(']], [[')(()()', '(((']], [[')))))((((', ')))))((((']], [['()((())))(', '()((()))(']], [['()', '']], [['(', '))']], [['))', ')']], [['()(', ')(']], [['()', '((((((())))']], [[')()()(', '((()))']], [['()(()))()', '()(()))()']], [[')(())()()(()()', ')(()()']], [[')))))(((', '(()(']], [['(((())))', '())']], [['()((())))', '()))']], [['()(()))()', ')))))(((']], [['(()(', '(()(']], [['()((())))', '(()))']], [['((', '(()))']], [['((((((((', '((((())))))))']], [['(()(', '))))))((()))']], [['(())())()()(()(()((()))))(', '(())())()()(()()(']], [['))()))(((', '(()(']], [['(()))', '((']], [[')()()(', '(()(']], [['((((((((', '(((())))']], [['((()))', '(()))']], [['(((', '(()))']], [['()(()))()(((((', '()(()))()']], [['(())())()()(()()(', '()((())))']], [['(((()(((((((', '((((())))))))']], [['()))', '(((())))']], [['(()))', '(()(']], [['(())())()()()(()))()(()()(', '()((())))']], [['))()))(((', '((']], [[')()()(', '(((())))']], [['((()(', '))()))()()())']], [['(()(', '))))))(()))(()))']], [['(', ')(()()(']], [['()))(((', '(((())))']], [['((())))))(', '))()))()()())']], [['(', '()(()))(']], [['((())))))(', '()(()))()']], [['()(()))(', '(()(']], [[')(()()', '(()()()(((((((']], [['(((())))', '()())(()()((()))(']], [['(((())))', '(()(']], [[')(()()(', '(()))']], [['(((()))', '()(())(']], [['()))))(((', '(()(']], [['()(()))(()', '()(()))()']], [[')))))(((', '(()))']], [[')()()(', '(((()()))']], [[')()()((', '(()(']], [['((())))))(', '(((())))']], [['(()))', ')(()()(']], [['((((((((', '))))']], [['(((()((((((()(()))()', '()(()))()']], [['()(()))()(((((', '()(())))))))()']], [['((((((((', '((()))']], [['(((()()()((((((((((((', '((((())))))))']], [['((((((((', '((((()))']], [['()(()))(', '((()(']], [['(', '(()))']], [['((())))))(', '()(())']], [['(()()()(((((((', '((((())))))))']], [['((())))))(', '()(()))()(((((']], [['(((((((', '((((())))))())']], [['(()))', '(()))']], [['(()))', '((((((())))']], [['((()(', '))()))()()()))()))((()']], [['))()))(((', '(((']], [[')(()()', '((()()()(((((((']], [['()))(((', '((((())))))))']], [['(()()()(((((((', '))()))()()()))()))(((((()()))()']], [[')(()()', '))()))()()()()(()())']], [['(((()()()((((((((((((', '((()(']], [['(((()()))', '()(()))()']], [['(((', '(((((())))))())']], [['((', '(()']], [['((()())))', '()())(()()((()))(']], [['((()(((', '(()(((']], [['(()((()()()((((((())', '(()))']], [['((()', '()(())(']], [['((())())))', '(()))']], [['((()))', ')(()()(']], [[')(()()', '))))']], [['())((((())))()(', ')))))(']], [['(((())))(()))()(((((', '()(()))()']], [['((((((())))', '(()(']], [['(((()))', '()())(()()((()))(']], [['((((((())))', '()']], [['(((()()(())()))', '(((()()))']], [['((()(', '))()))()()()))())))((()']], [['(', '()(()()']], [[')(()(()))(()()', ')(()()']], [[')()()', ')(()()']], [['((()', '((((()())))(())(']], [['(((((((())))', '(()(']], [['(((()()(())()))', '(()))']], [['()((())))', '((((())))))))']], [['((()((', '))()))()()()))())))((()']], [['()(())))))))(()', '()(()))()']], [['((((((((', '(((((((']], [['()(((', '((((())))))))']], [[')(()()()))(((', '(()()()(((((((']], [['()(())(()', '()(())))))))(()']], [[')()()(', '(((((((((']], [['(((()', '((((()())))(())(']], [['()(()())))', '()())(()()((()))(']], [['(()', '()(()))()']], [[')()()', ')((())())()()(()()(()()']], [['((()((', '(()()()((((())))))(()))(()))']], [['', '()(()))(']], [['(((((((', ')(()()']], [['(()))', '(((((((())))']], [['(()(', ')(()()()(((((((']], [['(())())()()()(()))()(()()(', '((()(()))())']], [['((()(', '))()))()())())']], [['(((())))(()))()(((((', '()(())))()']], [['((()(()))())', '((()(()))())']], [['(()()))))(((', '(()(']], [[')(()())(', ')(()()(']], [['(((()()(())()))', '(((()()(())()))']], [['(())())()()(()(()((()))))(', '(())((()((()()()((((((())))()()(()()(']], [['))))))(()))(()))', '))))))(()))(()))']], [[')(()())(', ')(']], [['(((())))(()))()(((((', '(((())))(()))()(((((']], [['(((()()(())()))', '))))']], [['))()))(((', ')))))(']], [['(((()()(())()))', '))']], [[')()(()', ')()()']], [['((()()()(((((((', '(()))']], [['(((()(())))))))(()()((', '()(()))()']], [['()(()()(()', '()(())))))))(()']], [['(((()()(())()))', '((((((((())))()))']], [['))()))()()()))()))))((()', '))()))()()()))())))((()']], [['()(()))()(((((', '()(()))()(((((']], [[')(()()((()()()((((((((', ')(()()(']], [['((()())))', '()())(()()(()()))(']], [['()((())))', '()(()())))']], [['((((((((())))))())((((', '((((()))']], [[')(()(()))(()()', '((((())))))))']], [['(((()))', '(((())))']], [[')))))(((', '(())']], [['(())())()()(()()(', '()))))(((']], [['())((((())))()(', ')(()((()()()((((((())())))((())']], [['((((((())))', '(()']], [['(()()()((((())))))(()))(()))', ')()()(']], [['(((((((', '(((()(((((((']], [['()(())(()', '()(())(()']], [[')(()()((()()()((((((((', '((()(((']], [[')())()', ')((())())()()(()()(()()']], [['((((((())))', '((()((((()(']], [['((((((())))', '))()))()()()))()))(((((()()))()']], [['()(())))()', '(()))']], [['()())(()()((()))(', '()())(()()((()))(']], [['(())()', '(()))']], [[')(()()', '()(())())()']], [['()(())))()', '(((()()(())()))']], [['((', '(())))']], [[')((())())()()(()(()((()))))(()())(', ')(']], [['((()((', '((()((']], [[')(())()', '()(())())()']], [['(((()(())))))))(()()((', '((((())))))())']], [['(()()))))(((', '()(()))()']], [[')((())())()()(()()(()()', '((((())))))))']], [['((((((((', '((((']], [[')()((', '(()(']], [['(())())()()()(()))()(()()(', '(']], [['())((((())))()(', '())((((())))()(']], [['(()()))))(((', '(()()))))(((']], [['()(', '((()']], [['(((())))', '(())(']], [['()))(((', '()(())(']], [['(())())()()(()(()((()))))(', '(())()(()((()()()((((((())))()()(()()(']], [[')((())())()()(()()(()()', '()(())(']], [['))()))()()()))())))((()', '))()))()()()))())))((()']], [['(()(', '()((']], [['(()()))))(((', '()(()))(']], [['(((()()))', '(())))']], [['((((((((', '(']], [['()))(((', '()))(((']], [[')))))(', '((((())))))))']], [['((()())))', '((()())))']], [['()(())(', '())((((())))()(']], [[')(()())(', '((((())))))))']], [[')()()', ')(()(())))))))()()']], [['((())())))', '()(()())))']], [['(((())))(()))()(((((', '))()))()()()))())))((()']], [['(((((', '))))']], [['(())())()()(()(()((()))))(', '))']], [[')(()()(', ')(()()(']], [['()()(())))', '()((())))']], [['(())())(((((((((', '()((())))']], [['(()())))))(((', '()(()))(']], [['(())())()()()(()))()(()()(', '(()))())']], [['(()(', ')))((()))']], [[')(()(()))(()()', '((((((((())))))())((((']], [[')()()', ')(()(())))))))()())']], [['(((()(', '))()))()()()))()))((()']], [['(())))', '((((())))))())']], [['()(())(()', '()(()))(']], [['(())(())())()()(()()(', '()(()))()']], [['(((((', '))()))()()()))()))((()']], [['(()()()((((())))))(()))(()))', '(((((((())))']], [[')(', '(()(']], [[')))()))()()()))()))))((()', '))()))()()()))())))((()']], [['()))))(((', '(())))']], [['))()))()()()))()))((()', '()((())))']], [['((())))))(', '(()()()((((())))))(()))(()))']], [[')(())()()(()()', '((()(']], [['()()())))))))(()', '()(())))))))(()']], [['(((((', '((((']], [['(()(', '))()))()()()()(()())']], [['))()))(((', ')))))(((']], [['((((', '))()))()())())']], [['(()((()()()((((((())', '(())))']], [[')(()(())((((())))()()(', '(()))']], [['(((()()(())()))', '(()))()))()()()))()))))((()(()()(())()))']], [['()())(()()((()))(', '(((())))']], [['(((()()))', '((((())))))))']], [[')(()()(', ')(()()(())()(']], [['))())()(())(((', ')))))(']], [['(((((', '()(()))()']], [[')(()(()))(()()', '()))(((']], [['((((((((', '()((())))']], [['(((())))', '()))(((']], [['(()(', ')))((()))((())))))(']], [[')()()(', '(())(())()(']], [['(())())()()()(()))()(())()(', '(']], [['((', '(((((((((']], [['(()(((', '()(()))()']], [[')(())()', ')))))(((']], [['()()(', '())((((())))()(']], [['(((()())', '())((((())))()(']], [['()())(()(()((()))(', '()(()())))']], [['(()()()(((((((', '))))))(()))(()))']], [['((((((())))', '()()(())))((()((((()(']], [[')()()(', '(()))()(']], [['))()))()()()))())))((()', '())()))()()()))())))((()']], [['(((()))', '()()(()()()(((((((())(']], [[')(()(()))(()()', '()))((((())()']], [['(()(())(()(((((())))', '(()(']], [['((((()())))(())(', '()(()))()']], [['((()(((', '((((()())))(())(']], [['()((())))', '))))))(()))(()))']], [['(()()()((((())))))(()))(()))', '((((((())))']], [['((())))))', '()(()))()(((((']], [['((()())))', '))()))()()()))())))((()']], [[')()()', ')((())())()()(()()(()(()']], [['(((()(((((((', '(((()(((((((']], [['))(()()((()()()((((((((', '()(()))()']], [['(()))', '()(()()(']], [['(()))', ')()(()(())))))))()())()()(']], [['))()))()()())', '))()))()()())']], [[')(()())(', ')(()()(((()(((((((']], [['(()()()((((())))))(()))(()))', '(()()()((((())))))(()))(()))']], [['((', '((((']], [['((((', '(((()()))']], [[')(()(())))))))()()', '()))(((']], [['(()))', '(())(']], [['()(()))()(((((', '(())))']]]\n    results = ['Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'Yes', 'No', 'No', 'No', 'Yes', 'Yes', 'No', 'No', 'No', 'Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'Yes', 'No', 'Yes', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'Yes', 'No']\n    for i, (inp, exp) in enumerate(zip(inputs, results)):\n        assertion(candidate(*inp), exp, 0)\n",
      "entry_point": "match_parens",
      "complete_code": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n"
    },
    "execution_info": {
      "max_mutations_per_operator": 10,
      "total_operators_tested": 46,
      "operators_with_mutations": 13,
      "execution_timestamp": "2025-08-01T15:54:11.129944"
    }
  }
}