{
  "timestamp": "20250801_153534",
  "test_type": "mutation_testing",
  "metadata": {
    "task_id": "HumanEval/6",
    "timestamp": "20250801_153534",
    "tester_version": "1.0",
    "total_operators_tested": 10,
    "operators_with_errors": 0
  },
  "summary": {
    "original_passes": true,
    "total_mutations": 27,
    "killed_mutations": 21,
    "mutation_score": 0.7777777777777778,
    "survival_rate": 0.2222222222222222
  },
  "detailed_results": {
    "task_id": "HumanEval/6",
    "dataset_type": "plus",
    "original_passes": true,
    "total_mutations": 27,
    "killed_mutations": 21,
    "mutation_score": 0.7777777777777778,
    "mutation_results": {
      "NumberReplacer": {
        "total_mutations": 8,
        "killed_mutations": 6,
        "survival_rate": 0.25,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (1, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (1, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:29.148385",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (-1, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (-1, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:29.303377",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 1)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 1)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmplid_8sb1.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplid_8sb1.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplid_8sb1.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:29.498470",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, -1)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, -1)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp3kzttzgc.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3kzttzgc.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3kzttzgc.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:29.672293",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 2\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 2\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp4zeakqch.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4zeakqch.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4zeakqch.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:29.829586",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 5,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 0\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 0\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpqgkpce9c.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqgkpce9c.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqgkpce9c.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:29.990557",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 6,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 2\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 2\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpjah48_5u.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjah48_5u.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjah48_5u.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:30.149872",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 7,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 0\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 0\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpyfk9l__1.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyfk9l__1.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyfk9l__1.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:30.311708",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 8,
        "mutations_tested": 8
      },
      "AddEq->SubEq": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt -= 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt -= 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp9ujh4qb3.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9ujh4qb3.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9ujh4qb3.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:30.532811",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "SubEq->AddEq": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt += 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt += 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpun2vglhr.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpun2vglhr.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpun2vglhr.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:30.750368",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Eq->NotEq": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch != '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch != '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmph4xxm2fs.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph4xxm2fs.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph4xxm2fs.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:30.935039",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch != ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch != ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpi1p64gtf.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpi1p64gtf.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpi1p64gtf.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:31.156838",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "NotEq->Eq": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s == '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s == '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpegkvgez2.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpegkvgez2.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpegkvgez2.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:31.382195",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Remove ReturnValue": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp4nps1_n3.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4nps1_n3.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4nps1_n3.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:31.570564",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpbfhcrfcq.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbfhcrfcq.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbfhcrfcq.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:31.761050",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "Zero->One": {
        "total_mutations": 2,
        "killed_mutations": 1,
        "survival_rate": 0.5,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (1, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (1, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:31.972402",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 1)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 1)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpv8pohj6x.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv8pohj6x.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv8pohj6x.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:32.145454",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "One->Zero": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 0\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 0\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp9rv0ux29.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9rv0ux29.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9rv0ux29.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:32.329034",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 0\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 0\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmptv11z7xa.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptv11z7xa.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptv11z7xa.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:32.491384",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "String->Empty": {
        "total_mutations": 3,
        "killed_mutations": 2,
        "survival_rate": 0.3333333333333333,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:32.642941",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp_magu2h5.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_magu2h5.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_magu2h5.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:32.844715",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == '':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == '':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpf1_bjxgp.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf1_bjxgp.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf1_bjxgp.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:32.991840",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split('') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split('') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp17yatllx.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp17yatllx.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n              ~~~~~~~~~^^^^^^\n  File \"/tmp/tmp17yatllx.py\", line 32, in parse_nested_parens\n    return [count_depth(s) for s in paren_string.split('') if s != '']\n                                    ~~~~~~~~~~~~~~~~~~^^^^\nValueError: empty separator\n",
            "timestamp": "2025-08-01T15:35:33.163567",
            "status": "BROKEN",
            "reason": "code_error"
          }
        ],
        "mutation_count_available": 4,
        "mutations_tested": 4
      },
      "String->X": {
        "total_mutations": 5,
        "killed_mutations": 3,
        "survival_rate": 0.4,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"X\"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"X\"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:33.326653",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == 'X':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == 'X':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpdzyxz7v4.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdzyxz7v4.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdzyxz7v4.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:33.550343",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == 'X':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == 'X':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp8tt2zyo1.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8tt2zyo1.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8tt2zyo1.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:33.720338",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split('X') if s != '']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split('X') if s != '']",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpn_0dcq8q.py\", line 70, in <module>\n    check(parse_nested_parens)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn_0dcq8q.py\", line 64, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn_0dcq8q.py\", line 57, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:33.887264",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
            "mutated_code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != 'X']",
            "mutated_complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def count_depth(s: str) -> int:\n        max_depth, cnt = (0, 0)\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            if ch == ')':\n                cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != 'X']",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:34.061261",
            "status": "SURVIVED",
            "reason": "tests_passed"
          }
        ],
        "mutation_count_available": 5,
        "mutations_tested": 5
      }
    },
    "problem_info": {
      "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "canonical_solution": "\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
      "test_code": "\n\nimport numpy as np\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\ndef assertion(out, exp, atol):\n    exact_match = out == exp\n\n    if atol == 0 and is_floats(exp):\n        atol = 1e-6\n    if not exact_match and atol != 0:\n        assert np.allclose(out, exp, rtol=1e-07, atol=atol)\n    else:\n        assert exact_match\n\n\ndef check(candidate):\n    inputs = [['(()()) ((())) () ((())()())'], ['() (()) ((())) (((())))'], ['(()(())((())))'], [''], ['((()))'], ['(())(()())'], ['(())(()(()))((()()))'], ['(()()(((())))(()(())))()'], ['()((()))'], ['(())'], ['()()()'], ['()(())'], ['(((())(()(()))((()()))))(()(()))((()()))'], ['(()()(()(())((()()(((())))(()(())))())(((()))))(()(())))()'], ['((()(())(()(()))((()()))))'], ['(()()(((())))(()(())(((())(()(()))((()()))))(()(()))((()()))))()'], ['((()()(((())))(()(())))())((()()))'], ['(()()(((())((()()(((())))(()(())))())(((()))))(()(()))))()'], ['()(()()(((())))(()(())(((())(()(()))((()()))))(()(()))((()()))))()((()))'], ['((()(())((()(()))((()())))))'], ['((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))'], ['((((((())(())))())((()()()(()(((()(()))))))))()(((())(()(()))((()()()))()))((()))()(()))()'], ['()()()()()()'], ['((((((()))(()()((()))))(()))))'], ['(((())))'], ['((()())()())'], ['()()()()()'], ['((((())()))()(()))(())'], ['((())()()()((((())(())))))'], ['(((((((()()()((()))(())()((()))((()())(())))))))()())()())'], ['((((())())))(())(())'], ['()(((())))'], ['(((((((())))))))'], ['(((((()(((()))))(()))()()())(())))()(())(())'], ['((())())()()'], ['((())()()((((())(())))))'], ['(()(())()())'], ['((((())(())))()()())((()))(())'], ['((()))()()()'], ['((((())())))(())'], ['(((((((((((((((())))))))))))))))'], ['((((((((((((())()()()))()))))(()))(())))))'], ['(((((((())((((())(())))))))())))()'], ['((((())((())))()(())))'], ['((((((((((()))))))((()))()))))'], ['(()(())())'], ['()'], ['((((((((((())))))))((()))((((((((())((((())(())))(((()()((())((()))(()((((()))()())))))())((((())))((()((((((())))))))))())))))()((((())))))))))))'], ['((((((((()(()))))))(((()))()))))'], ['((((((((((((((()))))))((()))()))))))))'], ['((((((((((((((()))))))((()))())((((((((()(()))))))(((()))())))))))))))'], ['((((())())(((((((())((((())(()))))(((()()((())((()))(()((((()))()())))))())((((())))((()((((((())))))))))())))))()((((()))))))))(())(())'], ['((((())((()))())(())))'], ['((())()())'], ['()()()()()((((((((((()))))))((()))()))))()'], ['((((((((((())))))((()))))(()))))'], ['((((((((((())))))))((()))((((((((())((((())(())))(((()()((())((()))(()((((()))()())))))())((((()))))((()(((((((())))))))))())))))()((((())))))))))))'], ['((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()((((()))))))))))((((((()()()((()))(())()(((((())))))))))))'], ['(((((()()()((()))(())()((()))())))))(()((((((((((()))))))((())))))))'], ['((((((()))(()()((())))))))'], ['(((((((()))))(()))))'], ['()()()()'], ['(((((()()()((()))(())()((()))((()())((((((()))(()()((()))))(()))))(())))))))'], ['((((((()))(()()((())(((((()()()((()))(())()((()))((()())(())))))))))))))'], ['(((())((((((()(()))))))((((((((((((()))))))((())(()))())))((()))))))((()))))'], ['((((((((()(())))()))(((())))()))))'], ['((((((((((()))))))((()))())))((())()()))'], ['(((((((())((((())(())))(((()()((())((()))(()(((((()))()())))))))((((())))((()((((((())))))))))())))))())((((()))))))'], ['(((((((((())((((())(())))(((()()((())((()))(()((((()))()())))))())((((())))((()((((((())))))))))())))))()((((()))))))((((())())))(())(())((((((((()))))))((())))())))((())()()))']]\n    results = [[2, 3, 1, 3], [1, 2, 3, 4], [4], [], [3], [2], [3], [5], [3], [2], [1], [2], [5], [8], [5], [7], [6], [9], [7], [6], [11], [10], [1], [8], [4], [3], [1], [5], [6], [10], [5], [4], [8], [9], [3], [6], [3], [5], [3], [5], [16], [13], [11], [6], [11], [3], [1], [22], [10], [15], [17], [19], [6], [3], [11], [11], [22], [12], [12], [8], [8], [1], [14], [14], [16], [10], [11], [18], [20]]\n    for i, (inp, exp) in enumerate(zip(inputs, results)):\n        assertion(candidate(*inp), exp, 0)\n",
      "entry_point": "parse_nested_parens",
      "complete_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n"
    },
    "execution_info": {
      "max_mutations_per_operator": 10,
      "total_operators_tested": 46,
      "operators_with_mutations": 10,
      "execution_timestamp": "2025-08-01T15:35:34.063227"
    }
  }
}