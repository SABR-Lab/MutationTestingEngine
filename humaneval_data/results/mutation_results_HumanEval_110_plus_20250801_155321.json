{
  "timestamp": "20250801_155321",
  "test_type": "mutation_testing",
  "metadata": {
    "task_id": "HumanEval/110",
    "timestamp": "20250801_155321",
    "tester_version": "1.0",
    "total_operators_tested": 10,
    "operators_with_errors": 0
  },
  "summary": {
    "original_passes": true,
    "total_mutations": 24,
    "killed_mutations": 22,
    "mutation_score": 0.9166666666666666,
    "survival_rate": 0.08333333333333337
  },
  "detailed_results": {
    "task_id": "HumanEval/110",
    "dataset_type": "plus",
    "original_passes": true,
    "total_mutations": 24,
    "killed_mutations": 22,
    "mutation_score": 0.9166666666666666,
    "mutation_results": {
      "NumberReplacer": {
        "total_mutations": 8,
        "killed_mutations": 8,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 3 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 3 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp5229d4zg.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp5229d4zg.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5229d4zg.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:15.775448",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 1 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 1 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpfvx02fcp.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpfvx02fcp.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvx02fcp.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:15.991356",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 2, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 2, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpd7e18kmc.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpd7e18kmc.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpd7e18kmc.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:16.241856",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 0, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 0, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpswi36u76.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpswi36u76.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpswi36u76.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:16.487605",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 3 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 3 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpx7zx48f1.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpx7zx48f1.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx7zx48f1.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:16.699851",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 5,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 1 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 1 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp6fq3gdpb.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp6fq3gdpb.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6fq3gdpb.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:16.937017",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 6,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 1, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 1, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp0ib6z0_o.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp0ib6z0_o.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0ib6z0_o.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:17.143525",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 7,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == -1, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == -1, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpnj8pzydo.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpnj8pzydo.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnj8pzydo.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:17.345999",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 8,
        "mutations_tested": 8
      },
      "Mod->FloorDiv": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x // 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x // 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp6v92hcue.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp6v92hcue.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6v92hcue.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:17.558325",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x // 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x // 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp3xh4odru.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp3xh4odru.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3xh4odru.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:17.802376",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "Eq->NotEq": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 != 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 != 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpsoyqrqff.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpsoyqrqff.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpsoyqrqff.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:18.046122",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 != 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 != 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpygpyiqkx.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpygpyiqkx.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpygpyiqkx.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:18.241086",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "LtEq->GtEq": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd >= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd >= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpykn4gj3b.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpykn4gj3b.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpykn4gj3b.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:18.497196",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Remove ReturnValue": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp2sq1tl10.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp2sq1tl10.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2sq1tl10.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:18.767298",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Zero->One": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 1, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 1, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpfpvns10p.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpfpvns10p.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfpvns10p.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:18.968864",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "One->Zero": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 0, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 0, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpci7m6pgv.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpci7m6pgv.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpci7m6pgv.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:19.171108",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "String->Empty": {
        "total_mutations": 3,
        "killed_mutations": 2,
        "survival_rate": 0.3333333333333333,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"\"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"\"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:53:19.367511",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return '' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return '' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpy4afe74y.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpy4afe74y.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpy4afe74y.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:19.585259",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else ''",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else ''",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpkzifr7i9.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpkzifr7i9.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkzifr7i9.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:19.833628",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 3,
        "mutations_tested": 3
      },
      "String->X": {
        "total_mutations": 3,
        "killed_mutations": 2,
        "survival_rate": 0.3333333333333333,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"X\"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"X\"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:53:20.107655",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'X' if cnt_odd <= cnt_even else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'X' if cnt_odd <= cnt_even else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpucf8e6oy.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpucf8e6oy.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpucf8e6oy.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:20.375871",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'X'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if cnt_odd <= cnt_even else 'X'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpdk98awqy.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpdk98awqy.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdk98awqy.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:20.599242",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 3,
        "mutations_tested": 3
      },
      "Ternary Condition": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if True else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if True else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp85b5s749.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmp85b5s749.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp85b5s749.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:20.844169",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
            "mutated_code": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if False else 'NO'",
            "mutated_complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return 'YES' if False else 'NO'",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpehxpt0zc.py\", line 68, in <module>\n    check(exchange)\n    ~~~~~^^^^^^^^^^\n  File \"/tmp/tmpehxpt0zc.py\", line 62, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpehxpt0zc.py\", line 55, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:53:21.085073",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      }
    },
    "problem_info": {
      "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n",
      "canonical_solution": "\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n",
      "test_code": "\n\nimport numpy as np\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\ndef assertion(out, exp, atol):\n    exact_match = out == exp\n\n    if atol == 0 and is_floats(exp):\n        atol = 1e-6\n    if not exact_match and atol != 0:\n        assert np.allclose(out, exp, rtol=1e-07, atol=atol)\n    else:\n        assert exact_match\n\n\ndef check(candidate):\n    inputs = [[[1, 2, 3, 4], [1, 2, 3, 4]], [[1, 2, 3, 4], [1, 5, 3, 4]], [[1, 2, 3, 4], [2, 1, 4, 3]], [[5, 7, 3], [2, 6, 4]], [[5, 7, 3], [2, 6, 3]], [[3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]], [[100, 200], [200, 200]], [[2, 4, 6], [1, 3, 5]], [[1, 3, 5], [2, 4, 6]], [[2, 2, 2], [1, 3, 5]], [[1, 3, 5], [2, 2, 2]], [[1, 3, 5, 7], [2, 4, 6]], [[2, 4, 6], [1, 3, 5, 7]], [[1, 3, 5, 7], [2, 4, 6, 8]], [[2, 4, 6, 8], [1, 3, 5, 7]], [[1, 3, 5, 7], [5, 7, 9, 11]], [[5, 7, 9, 11], [1, 3, 5, 7]], [[1, 5, 7], [5, 7, 9, 11]], [[2, 4, 6, 8, 8], [1, 3, 5, 7]], [[5, 7, 11], [1, 3, 5, 7]], [[1, 3, 5, 7, 7], [2, 4, 6, 8]], [[1, 3, 5, 7], [1, 3, 5, 7]], [[1, 3, 5, 7, 7], [2, 4, 6, 8, 6]], [[1, 3, 5, 7], [5, 7, 4, 11]], [[1, 3, 2, 7, 4, 7], [2, 4, 6, 8]], [[2, 4, 6, 8], [1, 3, 11, 7]], [[1, 3, 5, 7, 5], [1, 3, 5, 7, 5]], [[1, 3, 5], [1, 3, 5]], [[2, 4, 6, 6, 8, 6, 8], [1, 4, 3, 5, 7, 7]], [[1, 3, 2, 5, 7, 3], [1, 3, 2, 5, 7, 3]], [[5, 4, 3, 5, 7], [5, 4, 3, 5, 7]], [[1, 3, 5, 7, 3], [1, 3, 5, 7, 3]], [[1, 3, 2, 2, 7, 4, 7], [2, 4, 6, 8]], [[1, 3, 2, 5, 7, 3, 3], [1, 3, 2, 5, 7, 3, 3]], [[1, 3, 2, 5, 7, 7], [1, 3, 2, 5, 7, 7]], [[1, 3, 2, 5], [1, 3, 2, 5]], [[2, 4, 11, 6, 6], [1, 3, 5]], [[1, 2, 5, 7, 3, 3], [1, 2, 5, 7, 3, 3]], [[3, 5, 7], [3, 5, 7]], [[4, 1, 3, 5, 7, 3, 3], [4, 1, 3, 5, 7, 3, 3]], [[6], [1, 7, 7]], [[-1, 3, 5], [-1, 3, 5]], [[1, 3, 5, 7, 1, 5], [1, 3, 5, 7, 1, 5]], [[1, 2, 5, 7, 3], [1, 2, 5, 7, 3]], [[1, 3, 5, 7, 7], [1, 3, 5, 7, 7]], [[1, 3, 2, 7], [2, 4, 6]], [[2, 5, 4, 6], [2, 5, 4, 6]], [[1, 3, 5, 7, 1], [5, 7, 4, 11]], [[2, 4, 6, 3, 8], [1, 3, 5, 7]], [[1, 3, 5, 5, 1], [1, 3, 5, 5, 1]], [[2, 3, 6, 8, 2], [1, 3, 2, 7, 4, 7]], [[5, 7, 11], [1, 4, 3, 5, 7, 1]], [[1, 4, 5, 7], [1, 4, 5, 7]], [[5, 1, 3, 9, 5, 7], [5, 1, 3, 9, 5, 7]], [[4, 3, 5, 7, 7], [4, 3, 5, 7, 7]], [[3, 4, 7, 3], [3, 4, 7, 3]], [[1, 6, 3, 2, 5, 3, 5], [1, 6, 3, 2, 5, 3, 5]], [[5, 7, 4, 11], [1, 4, 3, 5, 7]], [[1, 8, 2, 5, 3, 3, 3], [1, 8, 2, 5, 3, 3, 3]], [[4, 1, 3, 5, 7, 3, 1, 3], [4, 1, 3, 5, 7, 3, 1, 3]], [[1, 3, 7, 3], [1, 3, 7, 3]], [[1, 3, 11], [2, 2]], [[2, 6, 8, 8], [2, 6, 8, 8]], [[1, 6, 3, 2, 5, 3, 5, 2], [1, 6, 3, 2, 5, 3, 5, 2]], [[1, 3, 2, 7], [2, 6, 6]], [[2, 4, 11, 6, 3, 11, 6], [2, 4, 11, 6, 3, 11, 6]], [[1, 3, 5, 7, 4, 7], [1, 3, 5, 7, 4, 7]], [[2, 2], [1, 3, 5]], [[1, 3, 3], [1, 3, 3]], [[2, 4, 6], [2, 4, 6]], [[5, 2, 3, 9, 5, 7, 2], [5, 2, 3, 9, 5, 7, 2]], [[7, 2, 4, 6, 8, 8], [1, 3, 5, 7]], [[6, 2, 2], [6, 2, 2]], [[1, 3, 2, 7, 8, 4, 7], [1, 3, 2, 7, 8, 4, 7]], [[2, 2], [3, 5]], [[5, 4, 4, 5, 7], [5, 4, 4, 5, 7]], [[1, 4, 5, 1, 7, 5], [1, 4, 5, 1, 7, 5]], [[1, 3, 5, 7, 0, 5], [1, 3, 5, 7, 0, 5]], [[-1, 1, 3], [-1, 1, 3]], [[5, 0, 2, 3, 9, 5, 7, 2], [5, 0, 2, 3, 9, 5, 7, 2]], [[1, 3, 5, 7, 1], [1, 3, 5, 7, 1]], [[1, 3, 2, 5, 7, 3, 5], [1, 3, 2, 5, 7, 3, 5]], [[1, 3, 2, 8, 5, 7, 3], [1, 3, 2, 8, 5, 7, 3]], [[2, 4, 6, 6], [2, 4, 6, 6]], [[1, 4, 11, 6, 3, 11, 6], [1, 4, 11, 6, 3, 11, 6]], [[2, 4, 6], [1, 3, 1, 4, 7]], [[1, 3, 1, 2, 2, 7, 4, 7], [1, 3, 1, 2, 2, 7, 4, 7]], [[1, 3, 2, 1, 2, 2, 7, 4, 7], [1, 3, 2, 1, 2, 2, 7, 4, 7]], [[1, 3, 11, 0, 7], [1, 3, 11, 0, 7]], [[1, 7, 7], [1, 7, 7]], [[2, -1, 11, 8], [2, -1, 11, 8]], [[4, 1, 3, 7, 3, 8, 3, 3], [4, 1, 3, 7, 3, 8, 3, 3]], [[5, 1, 3, 0, 9, 5, 7], [5, 1, 3, 0, 9, 5, 7]], [[1, 4, 5], [1, 4, 5]], [[4, 2, 3, 6, 7, 3, 1, 3], [4, 2, 3, 6, 7, 3, 1, 3]], [[1, 3, 2, 5, 5], [1, 3, 2, 5, 5]], [[4, 2, 3, 6, 7, 3, 1, 3, 4], [4, 2, 3, 6, 7, 3, 1, 3, 4]], [[3, 5, 7, 0, 5], [3, 5, 7, 0, 5]], [[5, 2, 4, 6, 4], [5, 2, 4, 6, 4]], [[0, 1, 4, 5], [0, 1, 4, 5]], [[1, 3, 5, 5, 5], [1, 3, 5, 5, 5]], [[3, 5, 4, 7], [3, 5, 4, 7]], [[2, 2, 2], [1, -1, 5]], [[4, 11, 6, 3, 11, 6], [4, 11, 6, 3, 11, 6]], [[2, 4, 8], [1, 3, 11, 7]], [[1, 3, 5, 7], [2, 4, 6, 8, 8]], [[1, 5, 7, 1, 7], [1, 5, 7, 1, 7]], [[1, 1, 1, 1], [2, 2, 2, 2]], [[7, 3, 5, 2], [4, 6, 8, 1]], [[1, 9, 11, 13], [2, 4, 6, 8]], [[1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1]], [[1, 3, 5, 7, 1, 3, 5, 7], [2, 4, 6, 8, 2, 4, 6, 8]], [[1, 2, 3, 4], [5, 6, 7, 8]], [[1, 1, 1, 1], [2, 2, 2, 2, 2, 2]], [[1, 1, 1, 2], [2, 2, 2, 2, 2, 2]], [[1, 1, 1, 2], [2, 2, 2, 2, 2, 2, 2]], [[1, 1, 1, 1], [2, 2, 2, 2, 9, 2, 2]], [[1, 1, 1, 3], [2, 2, 2, 2, 2, 2, 2]], [[3, 2, 2, 6, 2], [3, 2, 2, 6, 2]], [[2, 2, 6, 2], [2, 2, 6, 2]], [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1]], [[1, 1, 1, 2, 6, 1, 1], [1, 1, 1, 2, 6, 1, 1]], [[1, 1, 0, 1, 0], [1, 1, 0, 1, 0]], [[1, 5, 1, 0, 1, 1], [1, 5, 1, 0, 1, 1]], [[1, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 1, 0, 0]], [[4, 2, 2, 2, 2, 2, 2, 2], [4, 2, 2, 2, 2, 2, 2, 2]], [[2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2]], [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]], [[2, 2, 0, 6, 2], [2, 2, 0, 6, 2]], [[4, 2, 2, 2, 2, 2, 2, 2, 2], [4, 2, 2, 2, 2, 2, 2, 2, 2]], [[1, 1, 0, 1], [1, 1, 0, 1]], [[2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2]], [[5, 6, 2, 8, 2], [5, 6, 2, 8, 2]], [[1, 1, 1, 0, 1], [1, 1, 1, 0, 1]], [[1, 1, 1, 6, 1, 1], [1, 1, 1, 6, 1, 1]], [[4, 7, 7, 8, 1], [7, 3, 5, 2]], [[1, 1, 1, 11, 1], [2, 2, 2, 2, 9, 2, 2]], [[1, 9, 13], [2, 4, 6, 8]], [[5, 6, 6, 2, 8, 2], [5, 6, 6, 2, 8, 2]], [[2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2]], [[1, 1, 1, 9, 6, 1, 1, 1], [1, 1, 1, 9, 6, 1, 1, 1]], [[1, 3, 5, 7, 1, 3, 5, 7, 7, 3], [1, 3, 5, 7, 1, 3, 5, 7, 7, 3]], [[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2]], [[1, 2, 1, 1, 1], [2, 2, 2, 2]], [[3, 2, 2, 2], [3, 2, 2, 2]], [[1, 1, 1, 1, 9, 6, 1, 1, 1], [1, 1, 1, 1, 9, 6, 1, 1, 1]], [[2, 3, 6, 8], [1, 9, 11, 13]], [[1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 0]], [[3, 4, 2, 2, 4], [3, 4, 2, 2, 4]], [[2, 4, 6, 8, 2, 4, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7]], [[3, 4, 2, 2, 4, 2, 4], [3, 4, 2, 2, 4, 2, 4]], [[1, 1, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1]], [[2, 4, 6, 8, 1, 4, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7]], [[6, 1, 1, 0, 1], [6, 1, 1, 0, 1]], [[1, 1, 0], [1, 1, 0]], [[9, 6, 1, 1, 0, 1], [9, 6, 1, 1, 0, 1]], [[1, 1, 1, 1], [1, 1, 1, 1]], [[1, 1, 1, 9, 6, 1, 1], [1, 1, 1, 9, 6, 1, 1]], [[3, 4, 2, 2, 4, 3, 2, 4], [3, 4, 2, 2, 4, 3, 2, 4]], [[9, 6, 1, 1, 0, 1, 2], [9, 6, 1, 1, 0, 1, 2]], [[5, 2, 8, 2], [5, 2, 8, 2]], [[4, 7, 7, 8, 5, 1, 7], [4, 7, 7, 8, 5, 1, 7]], [[1, 1, 1, 2], [2, 2, 5, 2, 2, 2, 2]], [[1, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 0]], [[5, 6, 6, 2, 8, 2, 2], [5, 6, 6, 2, 8, 2, 2]], [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2]], [[7, 3, 5, 2, 2], [7, 3, 5, 2, 2]], [[1, 1, 1, 1, 1], [2, 2, 2, 2]], [[2, 2, 2, 2, 2, 2, 2], [6, 1, 1, 1, 1, 1, 1, 1]], [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], [[2, 4, 6, 8, 8], [2, 4, 6, 8, 8]], [[9, 6, 1, 1, 1, 2], [9, 6, 1, 1, 1, 2]], [[13, 1, 0, 1, 0], [13, 1, 0, 1, 0]], [[6, 1, 3, 5, 7, 1, 9, 7, 5, 7], [2, 4, 6, 2, 4, 6, 8]], [[1, 1, 1, 1], [2, 2, 2, 2, 1, 9, 2, 2]], [[1, 1, 1, 1, 9, 6, 1, 1], [1, 1, 1, 1, 9, 6, 1, 1]], [[1, 0, 1, 1, 1], [2, 2, 2]], [[1, 1, 11, 0, 0, 1, 0], [1, 1, 11, 0, 0, 1, 0]], [[1, 2, 3, 4, 3], [5, 6, 7, 8]], [[3, 3, 2, 2, 2, 2, 2], [3, 3, 2, 2, 2, 2, 2]], [[1, 5, 1, 0, 1, 1, 0], [1, 5, 1, 0, 1, 1, 0]], [[2, 2, 2, 2, 1, 2], [2, 2, 2, 2, 1, 2]], [[3, 2, 2, 2, 2], [3, 2, 2, 2, 2]], [[13, 2, 2, 2, 2], [13, 2, 2, 2, 2]], [[2, 2, 2], [2, 2, 2]], [[4, 7, 7, 8, 13, 5, 1, 7, 7], [4, 7, 7, 8, 13, 5, 1, 7, 7]], [[2, 4, 6, 9, 3, 1], [2, 4, 6, 9, 3, 1]], [[2, 2, 2, 2], [2, 2, 2, 2]], [[1, 2, 1, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1, 1]], [[2, 2, 2, 1, 2], [2, 2, 2, 1, 2]], [[1, 1, 6], [1, 1, 6]], [[9, 6, 1, 1, 0, 1, 5], [9, 6, 1, 1, 0, 1, 5]], [[1, 0, 1, 0, 0], [1, 0, 1, 0, 0]], [[2, 4, 6, 8, 8, 2], [2, 4, 6, 8, 8, 2]], [[3, 2, 2, 2, 2, 3], [3, 2, 2, 2, 2, 3]], [[2, 1, 1, 1, 1, 1], [2, 1, 1, 1, 1, 1]], [[2, 2, 0, 2, 2, 2, 1], [2, 2, 0, 2, 2, 2, 1]], [[1, 2, 1, 1, 1, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1, 1, 1, 1]], [[4, 7, 7, 8, 13, 5, 1, 7, 7, 7], [4, 7, 7, 8, 13, 5, 1, 7, 7, 7]], [[13, 2, 2, 5, 2, 2], [13, 2, 2, 5, 2, 2]], [[6, 1, 0, 1], [6, 1, 0, 1]], [[5, 5, 2, 8, 2], [5, 5, 2, 8, 2]], [[1, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1]], [[6, 1, 1, 0, 0], [6, 1, 1, 0, 0]], [[5, 5, 7, 2, 8, 2, 5], [5, 5, 7, 2, 8, 2, 5]], [[2, 5, 2, 2, 2, 2], [2, 5, 2, 2, 2, 2]], [[9, 6, 1, 1, 0], [9, 6, 1, 1, 0]], [[4, 7, 8, 5, 1, 7], [4, 7, 8, 5, 1, 7]], [[9, 6, 1, 1, 0, 2], [9, 6, 1, 1, 0, 2]], [[3, 4, 2, 3, 2, 4, 2, 4, 4], [3, 4, 2, 3, 2, 4, 2, 4, 4]], [[4, 6, 4, 4], [4, 6, 4, 4]], [[4, 7, 7, 8, 1], [4, 7, 7, 8, 1]], [[3, 4, 2, 3, 2, 4, 2, 4, 4, 4], [3, 4, 2, 3, 2, 4, 2, 4, 4, 4]], [[3, 0, 2, 6, 2], [3, 0, 2, 6, 2]], [[2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1, 1]], [[4, 6, 8, 8, 2], [4, 6, 8, 8, 2]], [[2, 4, 6, 8, 8, 2, 8], [2, 4, 6, 8, 8, 2, 8]], [[13, 5, 2, 2, 5, 1, 2], [13, 5, 2, 2, 5, 1, 2]], [[2, 4, 8, 8], [2, 4, 8, 8]], [[1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2]], [[1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2]], [[1, 1, 0, 3, 1, 0], [1, 1, 0, 3, 1, 0]], [[4, 7, 7, 8, 13, 5, 1, 7, 7, 13], [4, 7, 7, 8, 13, 5, 1, 7, 7, 13]], [[4, 7, 7, 7, 8, 13, 5, 1, 7, 7, 7], [4, 7, 7, 7, 8, 13, 5, 1, 7, 7, 7]], [[1, 1, 2], [1, 1, 2]], [[9, 6, 1, 0, 1], [9, 6, 1, 0, 1]], [[1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2]], [[1, 9], [2, 4, 6, 8]], [[1, 4, 7, 7, 8, 13, 5, 1, 7, 7, 7], [1, 4, 7, 7, 8, 13, 5, 1, 7, 7, 7]], [[2, 4, 6, 2, 4, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7]], [[2, 2, 2, 0, 6, 2, 2], [2, 2, 2, 0, 6, 2, 2]], [[5, 5, 2, 7, 2], [5, 5, 2, 7, 2]], [[2, 1, 1], [2, 1, 1]], [[1, 5, 1, 0, 1, 1, 1], [1, 5, 1, 0, 1, 1, 1]], [[1, 4, 7, 7, 8, 13, 1, 7, 7, 7], [1, 4, 7, 7, 8, 13, 1, 7, 7, 7]], [[1, 1, 5, 2], [1, 1, 5, 2]], [[1, 3, 7, 1, 3, 5, 7], [2, 4, 6, 8, 2, 4, 6, 8]], [[1, 5, 7, 1, 3, 5, 7], [2, 4, 6, 8, 2, 4, 6, 8]], [[6, 1, 3, 5, 7], [2, 4, 6, 8, 8]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 2]], [[1, 9], [4, 6, 8]], [[7, 2, 2, 2, 2], [7, 2, 2, 2, 2]], [[2, 4, 6, 5, 3, 1], [2, 4, 6, 5, 3, 1]], [[2, 4, 6, 2, 4, 6, 8], [1, 3, 7, 5, 7, 1, 3, 5, 6]], [[1, 1, 7, 0, 1], [1, 1, 7, 0, 1]], [[6, 1, 4, 5, 7, 1, 9, 7, 5, 7], [6, 1, 4, 5, 7, 1, 9, 7, 5, 7]], [[5, 6, 8, 8], [5, 6, 8, 8]], [[1, 0, 7, 0, 1], [1, 0, 7, 0, 1]], [[3, 0, 2, 7, 2], [3, 0, 2, 7, 2]], [[0, 7, 8, 5, 1, 7, 4], [0, 7, 8, 5, 1, 7, 4]], [[12, 2, 1, 2, 5, 2, 2, 2], [12, 2, 1, 2, 5, 2, 2, 2]], [[1, 2, 3, 4, 3], [6, 7, 8]], [[2, 2, 2, 2, 9, 2, 2], [2, 2, 2, 2, 9, 2, 2]], [[2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2]], [[3, 2, 0, 2], [3, 2, 0, 2]], [[2, 0, 2, 2, 2, 2, 2, 2], [2, 0, 2, 2, 2, 2, 2, 2]], [[13, 1, 0, 1], [13, 1, 0, 1]], [[1, 1, 11, 0, 0, 0, 1, 0, 1], [1, 1, 11, 0, 0, 0, 1, 0, 1]], [[2, 6, 2], [2, 6, 2]], [[2, 2, 0, 6, 2, 0], [2, 2, 0, 6, 2, 0]], [[2, 0, 2, 1, 2, 2, 2, 2, 2, 2], [2, 0, 2, 1, 2, 2, 2, 2, 2, 2]], [[3, 2, 2, 6, 2, 2], [3, 2, 2, 6, 2, 2]], [[1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1]], [[1, 0, 7, 0, 5, 1], [1, 0, 7, 0, 5, 1]], [[1, 9, 13], [2, 4, 6, 6, 8]], [[1, 4, 7, 7, 13, 5, 1, 7, 7, 7], [1, 4, 7, 7, 13, 5, 1, 7, 7, 7]], [[4, 7, 7, 8, 13, 5, 7, 7, 13], [4, 7, 7, 8, 13, 5, 7, 7, 13]], [[1, 2, 1, 1, 1], [2, 2, 2]], [[1, 1, 1, 1, 9, 6, 1, 1, 1, 1, 1], [1, 1, 1, 1, 9, 6, 1, 1, 1, 1, 1]], [[2, 2, 1, 2, 2, 2, 2, 2], [2, 2, 1, 2, 2, 2, 2, 2]], [[6, 1, 3, 5, 7], [6, 1, 3, 5, 7]], [[2, 2, 2, 2, 2, 2, 5, 2], [1, 1, 1, 2]], [[1, 3, 7, 5, 4, 7, 1, 3, 5, 6], [1, 3, 7, 5, 4, 7, 1, 3, 5, 6]], [[2, 4, 6, 6, 9, 3, 1, 6], [2, 4, 6, 6, 9, 3, 1, 6]], [[5, 6, 6, 2, 8, 2, 1], [5, 6, 6, 2, 8, 2, 1]], [[9, 6, 1, 1, 0, 1, 2, 1], [9, 6, 1, 1, 0, 1, 2, 1]], [[2, 1, 1, 1, 1, 1], [2, 2, 2, 2]], [[1, 8, 4, 7, 7, 13, 5, 1, 7, 7, 7, 7], [1, 8, 4, 7, 7, 13, 5, 1, 7, 7, 7, 7]], [[1, 2, 1, 1, 1], [1, 2, 1, 1, 1]], [[2, 2, 3, 2, 2, 2], [2, 2, 3, 2, 2, 2]], [[4, 8, 8, 2], [4, 8, 8, 2]], [[1, 8], [4, 6, 8]], [[5, 6, 6, 3, 8, 2], [5, 6, 6, 3, 8, 2]], [[7, 3, 1, 5, 2, 2, 5], [7, 3, 1, 5, 2, 2, 5]], [[6, 1, 1, 1, 0, 1], [6, 1, 1, 1, 0, 1]], [[9, 0, 6, 13, 1, 1], [9, 0, 6, 13, 1, 1]], [[6, 0, 1, 1], [6, 0, 1, 1]], [[1, 1, 0, 0, 1, 13, 1, 1], [1, 1, 0, 0, 1, 13, 1, 1]], [[8, 1, 2, 1, 1, 1, 1, 1, 2], [8, 1, 2, 1, 1, 1, 1, 1, 2]], [[1, 4, 7, 7, 11, 8, 13, 1, 7, 2, 7, 7], [1, 4, 7, 7, 11, 8, 13, 1, 7, 2, 7, 7]], [[9, 6, 1, 5, 5, 0], [9, 6, 1, 5, 5, 0]], [[5, 4, 6, 4], [5, 4, 6, 4]], [[1, 2, 6, 1, 1, 1, 1, 1, 1], [1, 2, 6, 1, 1, 1, 1, 1, 1]], [[4, 7, 7, 8, 5, 1, 7, 7, 7], [4, 7, 7, 8, 5, 1, 7, 7, 7]], [[2, 4, 13, 8, 8], [2, 4, 13, 8, 8]], [[13, 5, 2, 2, 8, 5, 1, 1], [13, 5, 2, 2, 8, 5, 1, 1]], [[3, 6, 2, 3, 2, 4, 2, 4, 4], [3, 6, 2, 3, 2, 4, 2, 4, 4]], [[1, 1], [1, 1]], [[13, 5, 2, 5, 2, 8, 5, 1, 1], [13, 5, 2, 5, 2, 8, 5, 1, 1]], [[1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0]], [[2, 13, 1, 0, 1, 0], [2, 13, 1, 0, 1, 0]], [[2, 2, 2, 2], [2, 1, 1, 1, 1, 1]], [[9, 6, 1, -1, 1, 0, 1, 2], [9, 6, 1, -1, 1, 0, 1, 2]], [[2, 2, 6, 2, 2, 2], [2, 2, 6, 2, 2, 2]], [[1, 0, 1, 1, 12], [1, 0, 1, 1, 12]], [[2, 4, 6, 8, 8], [1, 3, 7, 3]], [[2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 2, 1, 1, 1]], [[3, 4, 2, 2, 5, 2, 4], [3, 4, 2, 2, 5, 2, 4]], [[3, 5, 2, 2, 4], [3, 5, 2, 2, 4]], [[12, 12, 8], [12, 12, 8]], [[2, 1, 0, 1, 0], [2, 1, 0, 1, 0]], [[1, 5, 0, 1, 1], [1, 5, 0, 1, 1]], [[1, 5, 7, 1, 3, 5, 7, 7], [1, 5, 7, 1, 3, 5, 7, 7]], [[9, 1, 1, 1, 2], [9, 1, 1, 1, 2]], [[1, 2, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1]], [[12, 1, 1, 0, 1, 6], [12, 1, 1, 0, 1, 6]], [[1, 1, 11, 0, 0, 0, 1, 0, 1, 0], [1, 1, 11, 0, 0, 0, 1, 0, 1, 0]], [[5, 5, 2, 9, 2, 5], [5, 5, 2, 9, 2, 5]], [[1, 2, 1, 6, 1, 1, 1, 1, 1, 1, 1], [1, 2, 1, 6, 1, 1, 1, 1, 1, 1, 1]], [[1, 3, 7, 1, 3, 5, 7], [12, 4, 6, 8, 2, 4, 6, 8]], [[2, 4, 6, 2, 4, 6, 8], [1, 3, 7, 5, 7, 3, 5, 6]], [[5, 5, 7, 2, 8, 6, 2, 5], [5, 5, 7, 2, 8, 6, 2, 5]], [[2, 4, 6, 9, 3, 1, 2], [2, 4, 6, 9, 3, 1, 2]], [[2, 4, 8, 2], [2, 4, 8, 2]], [[9, 6, 0, 5, 1, 1, 0, 1], [9, 6, 0, 5, 1, 1, 0, 1]], [[3, 3, 2, 2, 2, 2], [3, 3, 2, 2, 2, 2]], [[6, 0, 1, 1, 6], [6, 0, 1, 1, 6]], [[-1, 7, 8, 5, 1, 7, 5, 4], [-1, 7, 8, 5, 1, 7, 5, 4]], [[9, 6, 1, -1, 0, 1, 2], [9, 6, 1, -1, 0, 1, 2]], [[3, 4, 2, 2, 4, 2], [3, 4, 2, 2, 4, 2]], [[1, 1, 1, 1, 9, 6, 7, 1, 1, 1, 1, 1], [1, 1, 1, 1, 9, 6, 7, 1, 1, 1, 1, 1]], [[2, 4, 1, 1, 1, 1], [2, 2, 2, 2]], [[2, 4, 6, 2, 4, 6, 8], [3, 7, 5, 7, 3, 5, 6]], [[9, 6, 1, 1, 1, 2, 2], [9, 6, 1, 1, 1, 2, 2]], [[2, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2]], [[5, 4, 6, 6, 4, 5], [5, 4, 6, 6, 4, 5]], [[7, 7, 3, 8, 1, 7, 7, 7], [7, 7, 3, 8, 1, 7, 7, 7]], [[5, 6, 13, 8, 8], [5, 6, 13, 8, 8]], [[5, 6, 9, 13, 8, 8], [5, 6, 9, 13, 8, 8]], [[5, 6, 6, 2, 8, 2, 8], [5, 6, 6, 2, 8, 2, 8]], [[2, 13, 1, 1, 0], [2, 13, 1, 1, 0]], [[3, 2, 1, 1, 1, 1, 1, 1, 2], [3, 2, 1, 1, 1, 1, 1, 1, 2]], [[6, 1, 1, 0, 2, 0], [6, 1, 1, 0, 2, 0]], [[1, 2, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1]], [[1, 2, 6, 1, 1, 1, 1, 1], [1, 2, 6, 1, 1, 1, 1, 1]], [[2, 2, 2, 2, 2, 2, 5, 2], [2, 2, 2, 2, 2, 2, 5, 2]], [[1, 5, 1, 0, 1, 1, 0, 1], [1, 5, 1, 0, 1, 1, 0, 1]], [[2, 1, 1, 5, 2], [2, 1, 1, 5, 2]], [[1, 8], [4, 6, 8, 4]], [[1, 1, 1, 9, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2]], [[6, 6, 8, 8], [6, 6, 8, 8]], [[13, 2, 2, 5, 5, 2, 2], [13, 2, 2, 5, 5, 2, 2]], [[1, 1, 2, 1, 1, 1, 1, 1], [1, 1, 2, 1, 1, 1, 1, 1]], [[1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0, 0]], [[2, 2, 2, 2, 2, 2, 5, 2, 2], [1, 1, 1, 2]], [[1, 0, 0, 1], [1, 0, 0, 1]], [[13, 1, 1], [13, 1, 1]], [[2, 2, 2, 2], [2, 1, 1, 1, 2, 1, 1]], [[1, 6], [1, 6]], [[1, 2, 7, 5, 4, 7, 1, 3, 5, 6], [1, 2, 7, 5, 4, 7, 1, 3, 5, 6]], [[4, 9, 11, 10, 13], [4, 9, 11, 10, 13]], [[9, 6, 0, 0, 5, 1, 1, 0, 1], [9, 6, 0, 0, 5, 1, 1, 0, 1]], [[1, 1, 1, 9, 6, 1, 1, 1, 1, 1], [1, 1, 1, 9, 6, 1, 1, 1, 1, 1]], [[1, 0, 1, 0], [1, 0, 1, 0]], [[6], [6]], [[13, 2, 2, 5, 2, 2, 2], [13, 2, 2, 5, 2, 2, 2]], [[5, 5, 2, 7, 2, 7], [5, 5, 2, 7, 2, 7]], [[5, 5, 7, 2, 8, 11, 6, 2, 5], [5, 5, 7, 2, 8, 11, 6, 2, 5]], [[2, 8, 2], [2, 8, 2]], [[1, 1, 2], [2, 2, 2, 2, 2, 2]], [[1, 1, -1, 1, 6, 1, 1], [1, 1, -1, 1, 6, 1, 1]], [[3, -1, 2, 6, 2, 3], [3, -1, 2, 6, 2, 3]], [[4, 7, 7, 7, 8, 13, 5, 1, 8, 7], [4, 7, 7, 7, 8, 13, 5, 1, 8, 7]], [[1, 3, 5, 7, 1, 3, 5, 7, 5], [2, 4, 6, 2, 4, 6, 8]], [[1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2]], [[1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 0, 1]], [[5, 2, 8, 2, 2], [5, 2, 8, 2, 2]], [[13, 2, 13], [13, 2, 13]], [[1, 1, 1, 1, 2, 9, 6, 1, 1], [1, 1, 1, 1, 2, 9, 6, 1, 1]], [[1, 3, 5, 7, 1, 3, 5, 7], [2, 4, 6, 12, 2, 4, 6, 8]], [[6, 1, 1, 0], [6, 1, 1, 0]], [[2, 2, 5, 2, 2], [2, 2, 5, 2, 2]], [[6, 1, 0, 2, 0], [6, 1, 0, 2, 0]], [[5, 5, 7, 2, 2, 5, 5], [5, 5, 7, 2, 2, 5, 5]], [[4, 6, 8, 8, 2, 8], [4, 6, 8, 8, 2, 8]], [[2, 2, 0, 2, 2, 2, 2], [2, 2, 0, 2, 2, 2, 2]], [[1, 1, 1, 2, 6, 1, 1, 6], [1, 1, 1, 2, 6, 1, 1, 6]], [[9, 6, 6, 1, 1, 2], [9, 6, 6, 1, 1, 2]], [[1, 2, 3, 4, 3, 1], [5, 6, 7, 8]], [[2, 2, 2, 2, 2, 2, 7, 2, 2], [2, 2, 2, 2, 2, 2, 7, 2, 2]], [[0, 1, 6, 0, 1, 0, 0, 0], [0, 1, 6, 0, 1, 0, 0, 0]], [[2, 5, 6, 2, 4, 6, 8], [2, 5, 6, 2, 4, 6, 8]], [[13, 13, 5, 2, 2, 8, 5, 1, 1], [13, 13, 5, 2, 2, 8, 5, 1, 1]], [[1, 3, 7, 1, 3, 5, 7, 1], [1, 3, 7, 1, 3, 5, 7, 1]], [[6, 1, 2, 0, 3], [6, 1, 2, 0, 3]], [[1, 2, 7, 5, 4, 7, 1, 3, 5, 5], [1, 2, 7, 5, 4, 7, 1, 3, 5, 5]], [[-1, 4, 13, 8, 8], [-1, 4, 13, 8, 8]], [[3, 4, 2, 1, 2, 5, 2, 4], [3, 4, 2, 1, 2, 5, 2, 4]], [[9, 6, 1, 0], [9, 6, 1, 0]], [[2, 4, 1, 1, 1, 1], [2, 2, 2, 2, 2]], [[2, 4, 6, 2, 4, 6, 8, 6], [2, 4, 6, 2, 4, 6, 8, 6]], [[9, 6, 1, -1, 0, 1, 2, 6], [9, 6, 1, -1, 0, 1, 2, 6]], [[2, 2, 2, 2, 2, 5, 2], [2, 2, 2, 2, 2, 5, 2]], [[13, 1, 1, 13], [13, 1, 1, 13]], [[3, 3, 10, 2, 2, 6, 2, 2, 6], [3, 3, 10, 2, 2, 6, 2, 2, 6]], [[2, 2, 0, 2], [2, 2, 0, 2]], [[1, 9], [1, 9]], [[13, 2, 2, 2, 2, 2], [13, 2, 2, 2, 2, 2]], [[1, 2], [1, 2]], [[6, 1, 1, 1, 0, 1, 1], [6, 1, 1, 1, 0, 1, 1]], [[3, 2, 1, 1, 1, 1, 0, 1, 2], [3, 2, 1, 1, 1, 1, 0, 1, 2]], [[2, -1, 1, 1, 1, 1], [2, -1, 1, 1, 1, 1]], [[1, 2, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1, 1, 1, 1, 1]], [[2, 4, 6, 8, 2, 4, 6, 8, 8], [2, 4, 6, 8, 2, 4, 6, 8, 8]], [[2, 2, 3, 2, 2, 2, 2], [2, 2, 3, 2, 2, 2, 2]], [[4, 7, 7, 5, 10, 7, 7, 7], [4, 7, 7, 5, 10, 7, 7, 7]], [[2, 2, 2, 2, 2, 2, 6], [2, 2, 2, 2, 2, 2, 6]], [[2, 1, 0, 0, 1, 1, 1, 2], [2, 1, 0, 0, 1, 1, 1, 2]], [[1, 1, 0, 0, 1, 1, -1, 1], [1, 1, 0, 0, 1, 1, -1, 1]], [[1, 5, 1, 5, 8, 7, 2, 2, 5, 5], [1, 5, 1, 5, 8, 7, 2, 2, 5, 5]], [[4, 7, 7, 7, 8, 1, 7, 7, 7], [4, 7, 7, 7, 8, 1, 7, 7, 7]], [[2, 4, 8, 6, 8, 8, 2], [2, 4, 8, 6, 8, 8, 2]], [[1, 4, 7, 6, 7, 13, 5, 1, 7, 7, 7], [1, 4, 7, 6, 7, 13, 5, 1, 7, 7, 7]], [[9, 2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1, 1]], [[6, 0, 1, 1, 0, 0], [6, 0, 1, 1, 0, 0]], [[7, 2, 2, 2, 2, 2], [7, 2, 2, 2, 2, 2]], [[2, 4, 6, 9, 9, 3, 1, 2], [2, 4, 6, 9, 9, 3, 1, 2]], [[1, 1, -1, 1, 1, 9, 6, 1, 1], [1, 1, -1, 1, 1, 9, 6, 1, 1]], [[1, 1, 1, 2, 6, 1, 1, 2], [1, 1, 1, 2, 6, 1, 1, 2]], [[4, 7, 7, 8, 13, 4, 5, 1, 7, 7], [4, 7, 7, 8, 13, 4, 5, 1, 7, 7]], [[10, 1, 11, 0, 0, -1, 1, 0], [10, 1, 11, 0, 0, -1, 1, 0]], [[13, 5, 1, 0, 1, 1], [13, 5, 1, 0, 1, 1]], [[6, 1, 1, 1, 0, 0], [6, 1, 1, 1, 0, 0]], [[1, 9, 9, 13], [2, 4, 6, 8]], [[4, 2, 1, 7, 2, 2], [4, 2, 1, 7, 2, 2]], [[2, 4, 6, 8, 2, 4, 6, 8, 8, 6], [2, 4, 6, 8, 2, 4, 6, 8, 8, 6]], [[1, 1, 1, 6, 1], [2, 2, 2, 9, 2, 2]], [[1, 3, 7, 4, 6, 1, 3, 5, 6], [1, 3, 7, 4, 6, 1, 3, 5, 6]], [[2, 2, 2, 2, 2, 3, 2, 2, 2], [1, 1, 1, 2]], [[3, 2, 2, 6, 2, 2, 2], [3, 2, 2, 6, 2, 2, 2]], [[13, 13], [13, 13]], [[3, 4, 2, 2, 4, 3], [3, 4, 2, 2, 4, 3]], [[4, 7, 7, 8, 13, 5, 1, 7, 7, 13, 8], [4, 7, 7, 8, 13, 5, 1, 7, 7, 13, 8]], [[9, 5, 1, 1, 1, 2], [9, 5, 1, 1, 1, 2]], [[2, 1, 1, 1, 0, 1, 0], [2, 1, 1, 1, 0, 1, 0]], [[7, 3, 2, 2, 2, 9, 2, 2], [7, 3, 2, 2, 2, 9, 2, 2]], [[2, 4, 6, 8, 2, 4, 6, 8, 8, 6, 6, 4], [2, 4, 6, 8, 2, 4, 6, 8, 8, 6, 6, 4]], [[8, 12, -1, 1, -1, 2, 5, 2, 2, 8], [8, 12, -1, 1, -1, 2, 5, 2, 2, 8]], [[5, 5, 7, 2, 6, 2, 5], [5, 5, 7, 2, 6, 2, 5]], [[1, 3, 5, 12, 7], [2, 4, 6, 8]], [[13, 1, 1, 1], [13, 1, 1, 1]], [[13, 2, 14, 13], [13, 2, 14, 13]], [[1, 3, 5, 7, 1, 3, 5, 7], [2, 4, 6, 8, 2, 4, 6, 8, 4]], [[9, 6, 1, 1, 2, 0, 1], [9, 6, 1, 1, 2, 0, 1]], [[13, 2, 2, 2, 2, 2, 2], [13, 2, 2, 2, 2, 2, 2]], [[0, 1, 1, 6], [0, 1, 1, 6]], [[1, 1, 6, 1, 6, 1, 1], [1, 1, 6, 1, 6, 1, 1]], [[9, 5, 1, 1, 1, 2, 1], [9, 5, 1, 1, 1, 2, 1]], [[4, 11, 2, 2, 2, 2, 2, 2], [4, 11, 2, 2, 2, 2, 2, 2]], [[1, 2, 1, 2], [2, 2, 5, 2, 2, 2, 2]], [[2, 4, 6, 8, 2, 3, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7]], [[1, 12, 1, 1, 2], [2, 2, 2, 2, 2, 2]], [[1, 2, 1, 2], [1, 2, 1, 2]], [[9, 1, 1, 0], [9, 1, 1, 0]], [[4, 7, 7, 8, 5, 1, 7, 9, 7, 4], [4, 7, 7, 8, 5, 1, 7, 9, 7, 4]], [[9, 6, 1], [9, 6, 1]], [[6, 6, 8, 8, 8], [6, 6, 8, 8, 8]], [[2, 4, 6, 8, 2, 4, 8, 8], [2, 4, 6, 8, 2, 4, 8, 8]], [[7, 2, 2, 7], [7, 2, 2, 7]], [[1, 3], [1, 3]], [[5, 5, 8, 2], [5, 5, 8, 2]], [[2, 1, 2, 1, 1, 0, 1, 0], [2, 1, 2, 1, 1, 0, 1, 0]], [[2, 2, 0, 2, 2], [2, 2, 0, 2, 2]], [[4, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2]], [[2, 5, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1]], [[2, 2, 2, 2, 2, 2, 2, 2], [0, 1, 1, 2, 2]], [[1, 5, 1, 0, 1], [1, 5, 1, 0, 1]], [[2, 13, 1, 0], [2, 13, 1, 0]], [[5, 6, 7, 8, 8], [5, 6, 7, 8, 8]], [[5, 5, 7, 2, 6, 2, 5, 6], [5, 5, 7, 2, 6, 2, 5, 6]], [[3, 4, 2, 2, 4, 3, 2, 4, 2], [3, 4, 2, 2, 4, 3, 2, 4, 2]], [[0, 1, 6, 0, 1, 0, 0, 0, 1], [0, 1, 6, 0, 1, 0, 0, 0, 1]], [[12, 4, 6, 8, 2, 4, 6, 8, 4], [12, 4, 6, 8, 2, 4, 6, 8, 4]], [[2, 6, 9, 3, 1, 5, 2], [2, 6, 9, 3, 1, 5, 2]], [[8, 6, 1, 4, 5, 7, 1, 9, 6, 7, 5, 7], [8, 6, 1, 4, 5, 7, 1, 9, 6, 7, 5, 7]], [[1, 2, 3, 4, 3], [5, 5, 7, 8, 8]], [[5, 5, 7, 2, 8, 2, 5, 2], [5, 5, 7, 2, 8, 2, 5, 2]], [[2, 4, 6, 6, 3, 9, 3, 1, 6, 4], [2, 4, 6, 6, 3, 9, 3, 1, 6, 4]], [[2, 2, 4], [2, 2, 4]], [[4, 7, 7, 8, 5, 1, 7, 7], [4, 7, 7, 8, 5, 1, 7, 7]], [[6, 1, 3, 1, 2, 0, 1, 1], [6, 1, 3, 1, 2, 0, 1, 1]], [[6, 6, 2, 8, 2, 2], [6, 6, 2, 8, 2, 2]], [[2, 4, 6, 2, 4, 9, 6, 8, 8], [1, 3, 7, 5, 7, 1, 3, 5, 6]], [[13, 5, 2, 5, 2, 8, 5, 1, 1, 5], [13, 5, 2, 5, 2, 8, 5, 1, 1, 5]], [[2, 2, 3, 2, 2, 2, 2, 3], [2, 2, 3, 2, 2, 2, 2, 3]], [[1, 1, 0, 9, 1], [1, 1, 0, 9, 1]], [[14, 5, 2, 5, 2, 8, 5, 1, 1, 7, 5], [14, 5, 2, 5, 2, 8, 5, 1, 1, 7, 5]], [[12, 2, 2, 1, 2, 5, 2, 2], [12, 2, 2, 1, 2, 5, 2, 2]], [[5, 6, 6, 3, 8, 2, 5], [5, 6, 6, 3, 8, 2, 5]], [[2, 13, 8, 8], [2, 13, 8, 8]], [[2, 3, 4], [5, 6, 7, 8]], [[1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1]], [[5, 7, 1, 3, 5, 7, 7], [5, 7, 1, 3, 5, 7, 7]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 2, 2, 1]], [[1, 2, 3, 5, 3, 2], [5, 5, 7, 8, 8]], [[2, 2, 1, 2, 2, 2, 2], [2, 2, 1, 2, 2, 2, 2]], [[1, 1, 1, 7, 1, 6, 1, 1, 1], [1, 1, 1, 7, 1, 6, 1, 1, 1]], [[1, 4, 7, 1, 3, 5, 7, 7], [2, 4, 6, 8, 2, 4, 6, 8]], [[9, 6, 1, 1, 0, 2, 9], [9, 6, 1, 1, 0, 2, 9]], [[13, 2, 5, 2, 2], [13, 2, 5, 2, 2]], [[13, 5, 2, 5, 2, 8, 5, 1, 1, 0, 5], [13, 5, 2, 5, 2, 8, 5, 1, 1, 0, 5]], [[5, 6, 6, 2, 11, 8, 2, 8, 2], [5, 6, 6, 2, 11, 8, 2, 8, 2]], [[1, 1, 2, 1], [2, 2, 2, 2, 2, 2]], [[4, 8, 5, 1, 7], [4, 8, 5, 1, 7]], [[2, 2, 1, 2, 2, 1, 2, 4, 2, 2], [2, 2, 1, 2, 2, 1, 2, 4, 2, 2]], [[2, 4, 6, 8, 2, 4, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7, 7]], [[0, 2, 6, 1, 1, 1, 1, 1], [0, 2, 6, 1, 1, 1, 1, 1]], [[5, 1, 5, 2, 8, 2], [5, 1, 5, 2, 8, 2]], [[14, 2, 0, 2, 2, 2, 1], [14, 2, 0, 2, 2, 2, 1]], [[1, 9, 2, 1, 1, 1, 1], [1, 9, 2, 1, 1, 1, 1]], [[1, 1, 9, 4, 7, 7, 13, 5, 1, 7, 7, 7, 1], [1, 1, 9, 4, 7, 7, 13, 5, 1, 7, 7, 7, 1]], [[3, 6, 3, 2, 3, 2, 4, 5, 4], [3, 6, 3, 2, 3, 2, 4, 5, 4]], [[7, 7, 8, 13, 1, 12, 13, 8], [7, 7, 8, 13, 1, 12, 13, 8]], [[2, 2, 2, 2, 2, 1], [1, 1]], [[1, 1, 7, 13, 5, 1, 7, 7, 7, 1], [1, 1, 7, 13, 5, 1, 7, 7, 7, 1]], [[0, 1, 1, 2, 2], [0, 1, 1, 2, 2]], [[9, 2, 4, 8, 2], [9, 2, 4, 8, 2]], [[4, 8, 5, 7, 5], [4, 8, 5, 7, 5]], [[13, 1, 1, 13, 1], [13, 1, 1, 13, 1]], [[1, 8, 2], [1, 8, 2]], [[2, 4, 6, 2, 4, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7, 7]], [[6, 1, 3, 5, 7, 1, 9, 7, 5, 7], [2, 10, 6, 2, 4, 6, -1, 8]], [[3, -1, 2, 2, 6, 2, 7], [3, -1, 2, 2, 6, 2, 7]], [[3, 2, 6, 2], [3, 2, 6, 2]], [[2, 2, 6, 2, 6], [2, 2, 6, 2, 6]], [[1, 4, 7, 7, 8, 13, 12, 1, 7, 7], [1, 4, 7, 7, 8, 13, 12, 1, 7, 7]], [[1, 3, 5, 6, 0, 7, 1, 3, 5, 7, 5, 1], [1, 3, 5, 6, 0, 7, 1, 3, 5, 7, 5, 1]], [[1, 2, 3, 4, 3, 1], [1, 2, 3, 4, 3, 1]], [[2, 4, 6, 2, 4, 6], [1, 3, 5, 7, 1, 3, 5, 7, 7]], [[3, 4, 2, 2, 4, 3, 2, 5], [3, 4, 2, 2, 4, 3, 2, 5]], [[2, 4, 6, 8, 2, 4, 6, 8], [2, 4, 6, 8, 2, 4, 6, 8]], [[2, 8, 6, 8], [2, 8, 6, 8]], [[1, 2, 3, 5, 2], [5, 5, 7, 8, 8]], [[1, 12, 1, 1, 2], [2, 2, 2, 2, 1, 2]], [[2, 0, 2, 2, 2, 1], [2, 0, 2, 2, 2, 1]], [[1, 1, 1, 6, 1], [1, 1, 1, 6, 1]], [[1, 2, 1, 1, 1, 1, 2, 1, 1, 1], [1, 2, 1, 1, 1, 1, 2, 1, 1, 1]], [[1, 1, 1, 1, 2, 9, 6, 1, 1, 1], [1, 1, 1, 1, 2, 9, 6, 1, 1, 1]], [[0, 1, 0], [0, 1, 0]], [[3, 2, 0, 5, 0], [3, 2, 0, 5, 0]], [[1, 2, 3, 4, 3, 2], [6, 7, 8]], [[9, 6, 1, -1, 1, 0, 1, 2, 2], [9, 6, 1, -1, 1, 0, 1, 2, 2]], [[1, 3, 4, 2, 1, 3, 5, 7], [1, 3, 4, 2, 1, 3, 5, 7]], [[13, 9, 7, 11, 13], [13, 9, 7, 11, 13]], [[1, 2, 1, 6, 1, 1, 1, 0, 13, 1, 1], [1, 2, 1, 6, 1, 1, 1, 0, 13, 1, 1]], [[2, 2, 2, 2, 2, 6], [2, 2, 2, 2, 2, 6]], [[1], [2, 2, 2, 2, 2, 2, 2]], [[4, 2, 2, 3, 2, 2, 2, 2, 2, 2], [4, 2, 2, 3, 2, 2, 2, 2, 2, 2]], [[5, 6, 7, 8, 7], [5, 6, 7, 8, 7]], [[1, 12, 1, 1, 2], [2, 2, 2, 2, 2, 2, 2]], [[2, 4, 6, 8, 2, 4, 6, 8, 8, 8], [2, 4, 6, 8, 2, 4, 6, 8, 8, 8]], [[9, 11, 8], [9, 11, 8]], [[-1, 13, 1, 0, 1, 0], [-1, 13, 1, 0, 1, 0]], [[4, 7, 7, 8, 13, 4, 5, 1, 7, 7, 8], [4, 7, 7, 8, 13, 4, 5, 1, 7, 7, 8]], [[13, 2, 3, 5, 2, 2], [13, 2, 3, 5, 2, 2]], [[2, 1, 6, 8, 2, 3, 6, 8], [1, 3, 5, 7, 1, 3, 5, 7]], [[6, 6, 3, 8, 2, 5, 5], [6, 6, 3, 8, 2, 5, 5]], [[1, 0, 1], [1, 0, 1]], [[5, 6, 2, 8], [5, 6, 2, 8]], [[9, 6, 1, 1, 0, 2, 8], [9, 6, 1, 1, 0, 2, 8]], [[9, 14, 6, 10, 1, 0], [9, 14, 6, 10, 1, 0]], [[2, 4], [2, 4]], [[3, 3, 2, 2, 2, 3], [3, 3, 2, 2, 2, 3]], [[1, 3, 7, 5, 7, 1, 4, 5, 6], [1, 3, 7, 5, 7, 1, 4, 5, 6]], [[1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0]], [[9, 6, 5, 1, 1, 0, 5], [9, 6, 5, 1, 1, 0, 5]], [[2, 6, 3, 1, 5, 2, 2], [2, 6, 3, 1, 5, 2, 2]], [[4, 7, 8, 5, 6, 1, 7, 1], [4, 7, 8, 5, 6, 1, 7, 1]], [[1, 1, 11, 0, 0, 1, 0, 1], [1, 1, 11, 0, 0, 1, 0, 1]], [[3, 0, 2, 7], [3, 0, 2, 7]], [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], [[12, 2, 4, 8, 8], [12, 2, 4, 8, 8]], [[1, 9, 13, 13], [2, 4, 6, 6, 8]], [[1, 2, 1, 1, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1, 1, 1]], [[1, 0, 0, 1, 13, 1], [1, 0, 0, 1, 13, 1]], [[2, 0, 2, 2, 1], [2, 0, 2, 2, 1]], [[2, 2, 2, 2, 2, 2, 2], [11, 1, 1, 1, 1]], [[2, 2, 3, 1, 2, 11, 2, 2, 2], [2, 2, 3, 1, 2, 11, 2, 2, 2]], [[13, 1, 0, 13], [13, 1, 0, 13]], [[1, 1, 11, 0, 0, 1, 0, 0, 0], [1, 1, 11, 0, 0, 1, 0, 0, 0]], [[6, 6, 2, 8, 2, 2, 6], [6, 6, 2, 8, 2, 2, 6]], [[1, 1, 11, 5, 0, 1, 0, 0, 0], [1, 1, 11, 5, 0, 1, 0, 0, 0]], [[1, 0, 0, 1, 1], [1, 0, 0, 1, 1]], [[3, 2, 2, 4], [3, 2, 2, 4]], [[1], [1]], [[1, 1, 2], [2, 2, 2, 2, 2, 2, 2]], [[5, 8, 3, 6, 6, 2, 11, 8, 2, 8], [5, 8, 3, 6, 6, 2, 11, 8, 2, 8]], [[5, 6, 2, 8, 10], [5, 6, 2, 8, 10]], [[1, 0, 12, 1], [1, 0, 12, 1]], [[0, 1, 6, 0, 1, 0, 0], [0, 1, 6, 0, 1, 0, 0]], [[4, 7, 7, 8, 5, 1, 7, 9, 4], [4, 7, 7, 8, 5, 1, 7, 9, 4]], [[8, 6, 1, 4, 5, 7, 1, 9, 6, 7, 7], [8, 6, 1, 4, 5, 7, 1, 9, 6, 7, 7]], [[1, 4, 6, 8, 8], [1, 3, 7, 3]], [[2, 4, 6, 5, 0, 1], [2, 4, 6, 5, 0, 1]], [[9, 1, 5, 2, 2, 2], [9, 1, 5, 2, 2, 2]], [[4, 7, 8, 5, 1, 7, 7], [4, 7, 8, 5, 1, 7, 7]], [[10, 2, 5, 2, 2], [10, 2, 5, 2, 2]], [[2, 2, 2, 2, 2, 3, 2, 2, 2, 2], [2, 2, 2, 2, 2, 3, 2, 2, 2, 2]], [[0, 0, 2, 6, 1, 1, 1, 1], [0, 0, 2, 6, 1, 1, 1, 1]], [[2, 2, 13, 8], [2, 2, 13, 8]], [[5, 8, 3, 6, 6, 2, 11, 3, 2, 8], [5, 8, 3, 6, 6, 2, 11, 3, 2, 8]], [[3, 4, 2, 7, 2, 4, 3, 2, 4], [3, 4, 2, 7, 2, 4, 3, 2, 4]], [[1, 3, 5, 12, 7, 12, 12], [1, 3, 5, 12, 7, 12, 12]], [[3], [5]], [[6], [8]], [[1, 3, 5], [2, 4]], [[1, 3], [2, 4, 6]], [[1, 3, 5], [7, 9, 11]], [[2, 4, 6], [8, 10, 12]], [[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]], [[1, 1, 1], [2, 2, 1, 2]], [[3, 2, 2, 2, 2, 2, 2, 2, 2], [3, 2, 2, 2, 2, 2, 2, 2, 2]], [[1, 1, 2, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2]], [[9, 11, 13], [9, 11, 13]], [[2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1]], [[3, 11, 13], [3, 11, 13]], [[12, 9, 11, 13], [12, 9, 11, 13]], [[3, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2], [3, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2]], [[2, 2], [2, 2]], [[1, 3, 5, 4, 7], [2, 4, 6, 9, 8]], [[3, 11, 13, 5, 11, 11], [3, 11, 13, 5, 11, 11]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 11, 1, 1, 1]], [[9, 11, 2, 13], [9, 11, 2, 13]], [[3, 11, 13, 5, 11, 11, 13], [3, 11, 13, 5, 11, 11, 13]], [[2, 4, 6, 8, 7], [2, 4, 6, 8, 7]], [[3, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2], [3, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2]], [[9, 11, 10, 13, 11], [9, 11, 10, 13, 11]], [[9, 11], [9, 11]], [[9, 10, 2, 11, 13], [9, 10, 2, 11, 13]], [[1, 1, 1, 1, 1], [2, 2, 2, 1, 2]], [[1, 1, 1, 11, 1, 1, 1], [1, 1, 1, 11, 1, 1, 1]], [[10, 2, 7, 13, 13], [10, 2, 7, 13, 13]], [[5, 2, 8, 1], [5, 2, 8, 1]], [[1, 5, 7, 1, 3, 5, 7, 3], [2, 4, 6, 8, 2, 4, 6, 8]], [[1, 1, 1], [1, 1, 1]], [[2, 2, 2, 2, 2, 2], [1, 1, 1, 11, 1, 1, 1]], [[5, 2, 8, 0], [5, 2, 8, 0]], [[11, 11], [11, 11]], [[2, 3, 2], [2, 3, 2]], [[2, 4, 7, 8, 7, 7], [2, 4, 7, 8, 7, 7]], [[12, 9, 11, 10, 13, 9], [12, 9, 11, 10, 13, 9]], [[2, 2, 11, 2, 2, 3, 2], [1, 1, 1, 1, 1, 1, 1]], [[9, 6, 0, 0], [9, 6, 0, 0]], [[9, 10, 2, 11], [9, 10, 2, 11]], [[9, 10, 5, 2, 11], [9, 10, 5, 2, 11]], [[1, 5, 7, 1, 3, 5, 7, 3, 5], [2, 4, 6, 8, 2, 4, 6, 8]], [[1, 1, 1, 1, 1], [2, 2, 1, 2, 1, 2]], [[5, 2, 8, 4, 1], [5, 2, 8, 4, 1]], [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]], [[1, 5, 7, 1, 3, 6, 7, 3, 5], [1, 5, 7, 1, 3, 6, 7, 3, 5]], [[9, 0, 10, 2, 11], [9, 0, 10, 2, 11]], [[2, 8, 0], [2, 8, 0]], [[1, 8, 3, 4], [5, 6, 7, 8]], [[3, 13, 5, 11, 11, 13], [3, 13, 5, 11, 11, 13]], [[3, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 2, 2, 2, 2, 2, 2, 2, 2, 2]], [[9, 11, 10, 9, 11, 13], [9, 11, 10, 9, 11, 13]], [[3, 11, 13, 11, 5, 11, 11], [3, 11, 13, 11, 5, 11, 11]], [[5, 8, 4, 1], [5, 8, 4, 1]], [[1, 1, 1], [2, 2, 2, 2, 2, 2, 2]], [[3, 11, 13, 11, 5, 10, 11], [3, 11, 13, 11, 5, 10, 11]], [[9, 6, 11, 13, 10], [9, 6, 11, 13, 10]], [[1, 1, 1, 2, 1], [2, 2, 2, 2, 2, 2, 2]], [[10, 2], [10, 2]], [[3, 4, 13, 11, 5, 10, 11], [3, 4, 13, 11, 5, 10, 11]], [[8, 11, 10, 10, 11, 13], [8, 11, 10, 10, 11, 13]], [[1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 1, 1, 1, 1, 1, 1, 1, 11]], [[9, 2, 11, 13], [9, 2, 11, 13]], [[9, 10, 2, 11, 10], [9, 10, 2, 11, 10]], [[1, 1, 1, 11, 11, 1, 1, 1], [1, 1, 1, 11, 11, 1, 1, 1]], [[8, 9, 11, 2, 13, 11], [8, 9, 11, 2, 13, 11]], [[1, 5, 7, 1], [1, 5, 7, 1]], [[5, 2, 8, 1, 5], [5, 2, 8, 1, 5]], [[9, 6, 11, 13, 10, 9], [9, 6, 11, 13, 10, 9]], [[9, 11, 13, 9], [9, 11, 13, 9]], [[1, 5, 7, 1, 3, 5, 7, 3, 7, 3], [1, 5, 7, 1, 3, 5, 7, 3, 7, 3]], [[1, 5, 7], [1, 5, 7]], [[5, 6, 7, 8], [5, 6, 7, 8]], [[3, 12, 11], [3, 12, 11]], [[1, 5, 7, 1, 3, 6, 7, 5], [1, 5, 7, 1, 3, 6, 7, 5]], [[9, 11, 2, 14], [9, 11, 2, 14]], [[3, 12, 11, 12, 12], [3, 12, 11, 12, 12]], [[9, 0, 10, 5, 2, 11], [9, 0, 10, 5, 2, 11]], [[9], [9]], [[1, 5, 7, 1, 3, 10, 6, 7, 3, 5], [1, 5, 7, 1, 3, 10, 6, 7, 3, 5]], [[1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1, 1]], [[10, 9, 10, 2, 11, 10], [10, 9, 10, 2, 11, 10]], [[2, 2, 2, 2, 2], [1, 1, 8, 11, 1, 1, 1]], [[3, 2, 2, 2, 2, 2, 2, 2, 6, 2], [3, 2, 2, 2, 2, 2, 2, 2, 6, 2]], [[2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 11, 1, 1, 1]], [[1, 5, 7, 1, 3, 5, 7, 3, 2, 7, 3], [1, 5, 7, 1, 3, 5, 7, 3, 2, 7, 3]], [[3, 11, 13, 11, 5, 10, 11, 13], [3, 11, 13, 11, 5, 10, 11, 13]], [[2, 2, 5, 2, 2, 2, 2, 2, 2], [2, 2, 5, 2, 2, 2, 2, 2, 2]], [[11, 3, 12], [11, 3, 12]], [[8, 10, 11, 13], [8, 10, 11, 13]], [[2, 2, 2, 2, 2], [1, 12, 8, 11, 1, 1, 1]], [[1, 1, 1, 1], [2, 2, 2]], [[9, 11, 11, 13, 13], [9, 11, 11, 13, 13]], [[5, 2, 8, 1, 8, 8], [5, 2, 8, 1, 8, 8]], [[5, 2, 8, 1, 8, 8, 2], [5, 2, 8, 1, 8, 8, 2]], [[1, 1, 11, 11, 1, 1, 1], [1, 1, 11, 11, 1, 1, 1]], [[2, 8], [2, 8]], [[2, 6, 8, 2, 10, 4, 6, 8], [2, 6, 8, 2, 10, 4, 6, 8]], [[3, 11, 13, 5, 11, 13], [3, 11, 13, 5, 11, 13]], [[3, 11, 13, 5, 11, 11, 11], [3, 11, 13, 5, 11, 11, 11]], [[11, 13, 9], [11, 13, 9]], [[9, 6, 11, 13, 1, 9], [9, 6, 11, 13, 1, 9]], [[2, 8, 0, 8], [2, 8, 0, 8]], [[9, 9, 11, 10, 13, 11], [9, 9, 11, 10, 13, 11]], [[1, 7, 1], [1, 7, 1]], [[1, 12, 13, 8, 11, 1, 1, 1, 1], [1, 12, 13, 8, 11, 1, 1, 1, 1]], [[1, 5, 7, 1, 3, 2, 5, 7, 3, 2, 7, 3], [1, 5, 7, 1, 3, 2, 5, 7, 3, 2, 7, 3]], [[11, 9], [11, 9]], [[5, 2, 1, 5, 1], [5, 2, 1, 5, 1]], [[9, 0, 10, 10, 11], [9, 0, 10, 10, 11]], [[1, 5, 7, 1, 3, 2, 5, 7, 3, 2, 7, 7, 3, 7], [1, 5, 7, 1, 3, 2, 5, 7, 3, 2, 7, 7, 3, 7]], [[8, 2, 8, 1, 5], [8, 2, 8, 1, 5]], [[8, 10, 10, 13, 10], [8, 10, 10, 13, 10]], [[10, 9], [10, 9]], [[7, 2, 11, 13], [7, 2, 11, 13]], [[12, 9, 11, 13, 10, 13, 13, 9], [12, 9, 11, 13, 10, 13, 13, 9]], [[2, 2, 2, 2, 2, 2, 2], [0, 1, 1, 1, 1, 1]], [[8, 2, 8, 1, 5, 8], [8, 2, 8, 1, 5, 8]], [[2, 2, 4, 6, 8], [2, 2, 4, 6, 8]], [[1, 1, 2, 1, 1, 7, 1], [2, 2, 2, 2, 2, 3, 2]], [[10, 9, 6, 10, 13, 1, 9], [10, 9, 6, 10, 13, 1, 9]], [[9, 0, 0], [9, 0, 0]], [[13, 9, 11, 13], [13, 9, 11, 13]], [[1, 5], [1, 5]], [[1, 0, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1]], [[3, 4, 4, 13, 11, 5, 10, 11], [3, 4, 4, 13, 11, 5, 10, 11]], [[1, 1, 1, 11, 2, 1, 1, 1], [1, 1, 1, 11, 2, 1, 1, 1]], [[1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2]], [[3, 2, 2, 2, 2, 2, 2, 2, 3, 2], [3, 2, 2, 2, 2, 2, 2, 2, 3, 2]], [[2, 6, 8, 2, 10, 6], [2, 6, 8, 2, 10, 6]], [[1, 5, 7, 1, 3, 7, 7], [1, 5, 7, 1, 3, 7, 7]], [[9, 11, 8, 2, 13], [9, 11, 8, 2, 13]], [[7, 5, 2, 8, 1, 8, 8], [7, 5, 2, 8, 1, 8, 8]], [[3, 7, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2], [3, 7, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2]], [[2, 2, 4, 7, 9], [2, 2, 4, 7, 9]], [[2, 2, 2, 2, 2, 2, 3, 2], [1, 1, 1, 1, 1, 1]], [[2, 10, 9, 12, 10, 1, 9], [2, 10, 9, 12, 10, 1, 9]], [[2, 2, 5, 2, 2, 11, 3, 2, 2, 2], [2, 2, 5, 2, 2, 11, 3, 2, 2, 2]], [[3, 13, 7, 11, 11, 13], [3, 13, 7, 11, 11, 13]], [[2, 2, 2, 8, 2], [1, 1, 1, 1, 1, 1, 1]], [[9, 9, 11, 13], [9, 9, 11, 13]], [[5, 2, 0, 8, 1], [5, 2, 0, 8, 1]], [[1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1]], [[2, 8, 6, 8, 2, 4, 6, 8, 8, 2], [2, 8, 6, 8, 2, 4, 6, 8, 8, 2]], [[10, 2, 2], [10, 2, 2]], [[3, 4, 13, 11, 5, 10, 11, 5], [3, 4, 13, 11, 5, 10, 11, 5]], [[3, 4, 13, 5, 10, 11], [3, 4, 13, 5, 10, 11]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1, 1]], [[3, 13, 11, 5, 10, 11], [3, 13, 11, 5, 10, 11]], [[8, 8, 1, 5, 5], [8, 8, 1, 5, 5]], [[9, 2, 11, 11, 1, 13], [9, 2, 11, 11, 1, 13]], [[2, 3, 7, 8, 7, 7, 7], [2, 3, 7, 8, 7, 7, 7]], [[9, 11, 11, 1, 13, 13], [9, 11, 11, 1, 13, 13]], [[1, 5, 7, 1, 3, 10, 12, 7, 3, 5], [1, 5, 7, 1, 3, 10, 12, 7, 3, 5]], [[10, 11, 13], [10, 11, 13]], [[2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1]], [[2, 2, 11, 4, 2, 2, 3, 2], [1, 1, 1, 1, 1, 1, 1]], [[3, 2, 2, 2, 2, 4, 2, 2, 2, 2], [3, 2, 2, 2, 2, 4, 2, 2, 2, 2]], [[3, 11, 13, 5, 13], [3, 11, 13, 5, 13]], [[2, 2, 2, 5, 2], [2, 2, 2, 5, 2]], [[10, 9, 6, 10, 13, 9], [10, 9, 6, 10, 13, 9]], [[2, 3, 7, 8, 6, 7, 7, 2], [2, 3, 7, 8, 6, 7, 7, 2]], [[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2], [3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2]], [[1, 5, 7, 1, 3, 6, 7], [1, 5, 7, 1, 3, 6, 7]], [[0, 1, 1, 1, 1], [2, 2, 1, 2, 1, 2]], [[1, 1, 2, 1, 1, 1, 1], [1, 1, 2, 1, 1, 1, 1]], [[9, 10, 5, 11], [9, 10, 5, 11]], [[12, 9, 11, 13, 10, 10, 13, 9, 12], [12, 9, 11, 13, 10, 10, 13, 9, 12]], [[1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 2]], [[5, 2, 8, 1, 8, 2], [5, 2, 8, 1, 8, 2]], [[3, 4, 14, 13, 11, 5, 10, 11], [3, 4, 14, 13, 11, 5, 10, 11]], [[10, 1, 11, 10], [10, 1, 11, 10]], [[11, 13, 4, 9], [11, 13, 4, 9]], [[10, 13], [10, 13]], [[5, 2, 8, 1, 8, 7, 2], [5, 2, 8, 1, 8, 7, 2]], [[1, 2, 1, 1, 7, 1], [2, 2, 2, 2, 2, 3, 2, 2]], [[2, 3, 7, 8, 6, 1, 7, 2], [2, 3, 7, 8, 6, 1, 7, 2]], [[9, 6, 0, 0, 0], [9, 6, 0, 0, 0]], [[5, 2, 2, 4, 7, 9, 2], [5, 2, 2, 4, 7, 9, 2]], [[3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3], [3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3]], [[1, 1, 2, 1, 1, 1, 1, 1, 2], [1, 1, 2, 1, 1, 1, 1, 1, 2]], [[9, 11, 11], [9, 11, 11]], [[0, 9, 11, 9], [0, 9, 11, 9]], [[10, 1], [10, 1]], [[2, 2, 2, 9, 2, 14], [2, 2, 2, 9, 2, 14]], [[9, 1, 1, 9], [9, 1, 1, 9]], [[5, 2, 8, -1], [5, 2, 8, -1]], [[10, 9, 2, 11, 9], [10, 9, 2, 11, 9]], [[2, 2, 2, 2, 2, 3, 2], [2, 2, 2, 2, 2, 3, 2]], [[13, 5, 11, 11, 1], [13, 5, 11, 11, 1]], [[2, 2, 2, 2, 1, 3, 2], [2, 2, 2, 2, 1, 3, 2]], [[8, 10, 10, 13, 10, 10], [8, 10, 10, 13, 10, 10]], [[-1, 5, 7, 1, 3, 10, 6, 7, 3, 5, 10], [-1, 5, 7, 1, 3, 10, 6, 7, 3, 5, 10]], [[2, 2, 2, -1, 0, 2, 1, 3, 2, -1, 1], [2, 2, 2, -1, 0, 2, 1, 3, 2, -1, 1]], [[1, 1, 1, 2, 1], [1, 1, 1, 2, 1]], [[2, 2, 2, -1, 0, 2, 1, 3, 2, -1, 1, -1, 2, 2], [2, 2, 2, -1, 0, 2, 1, 3, 2, -1, 1, -1, 2, 2]], [[2, 2, 11, 2, 2, 2, 2], [2, 2, 11, 2, 2, 2, 2]], [[2, 2, 2, 5, 2, 2], [2, 2, 2, 5, 2, 2]], [[1, 5, 7, 1, 3, 10, 6, 7, 3, 5, 7], [1, 5, 7, 1, 3, 10, 6, 7, 3, 5, 7]], [[8, 9, 11, 13, 13, 11], [8, 9, 11, 13, 13, 11]], [[1, 2, 7], [1, 2, 7]], [[10, 13, 13], [10, 13, 13]], [[5, 2, 8, 4, 8, 7, 2], [5, 2, 8, 4, 8, 7, 2]], [[1, 1, 1, 1], [2, 2]], [[9, 10, 5, 11, 10, 10], [9, 10, 5, 11, 10, 10]], [[8, 2, 8, 5, 8, 1, 8], [8, 2, 8, 5, 8, 1, 8]], [[3, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 6, 6, 2], [3, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 6, 6, 2]], [[2, 0, 8, 1, 2], [2, 0, 8, 1, 2]], [[9, 12, 11], [9, 12, 11]], [[-1, 10, 9], [-1, 10, 9]], [[2, 2, 2, 9, 0, 2, 14], [2, 2, 2, 9, 0, 2, 14]], [[3, 12, 11, 12, 12, 12], [3, 12, 11, 12, 12, 12]], [[1, 5, 7, 1, 3, 6, 7, 7], [1, 5, 7, 1, 3, 6, 7, 7]], [[9, 8, 11, 13], [9, 8, 11, 13]], [[3, 2, 2, 14, 2, 2, 2, 2, 2, 3, 2, 2], [3, 2, 2, 14, 2, 2, 2, 2, 2, 3, 2, 2]], [[2, 2, 11, 3, 2, 2, 2, 2, 2, 2], [2, 2, 11, 3, 2, 2, 2, 2, 2, 2]], [[9, 10, 1, 11, 10, 10], [9, 10, 1, 11, 10, 10]], [[1, 1, 2, 1, 7, 1], [1, 1, 2, 1, 7, 1]], [[3, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2, 2], [3, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2, 2]], [[10, 5, 11], [10, 5, 11]], [[5, 5, 6, 7, 8], [5, 5, 6, 7, 8]], [[2, 6, 8, 2, 10, 4, 6], [2, 6, 8, 2, 10, 4, 6]], [[1, 1, 2, 1], [1, 1, 2, 1]], [[2, 2, 5, 2, 2, 2, 2, 1, 2], [2, 2, 5, 2, 2, 2, 2, 1, 2]], [[3, 3, 6, 13, 7, 11, 11, 6, 11], [3, 3, 6, 13, 7, 11, 11, 6, 11]], [[11, 0, 3, 12], [11, 0, 3, 12]], [[3, 4, 13, 8, 5, 11, 5], [3, 4, 13, 8, 5, 11, 5]], [[9, 0, 10, 1, 11], [9, 0, 10, 1, 11]], [[2, 2, 2, 2, 9, 2, 2, 2], [2, 2, 2, 2, 9, 2, 2, 2]], [[9, 11, 11, 1, 13, 1], [9, 11, 11, 1, 13, 1]], [[2, 2, 2, 1, -1, 0, 2, 1, 3, 2, -1, 1], [2, 2, 2, 1, -1, 0, 2, 1, 3, 2, -1, 1]], [[3, 2, 0, 2, 2, 2, 2, 2, 6, 2, 2], [3, 2, 0, 2, 2, 2, 2, 2, 6, 2, 2]], [[1, 5, 5, 8, 1], [2, 4, 6, 8]], [[3, 13, 7, 11, 7, 11, 13], [3, 13, 7, 11, 7, 11, 13]], [[5, 2, 0, 8], [5, 2, 0, 8]], [[7, 5, 2, 8, 1, 8, 7, 2], [7, 5, 2, 8, 1, 8, 7, 2]], [[8, 10, 11, 13, 8], [8, 10, 11, 13, 8]], [[9, 2, 10, 13, 9], [9, 2, 10, 13, 9]], [[14, 1, 3, 1], [14, 1, 3, 1]], [[9, 1, 1, 2], [9, 1, 1, 2]], [[9, 5, 11, 5], [9, 5, 11, 5]], [[2, 2, 2, 1, -1, 4, 2, 1, 3, 2, -1, 1], [2, 2, 2, 1, -1, 4, 2, 1, 3, 2, -1, 1]], [[1, 1, 1, 1], [0, 1, 2, 2, 2, 2, 2, 2, 2]], [[-1, 4, 6, 8, 7], [-1, 4, 6, 8, 7]], [[0, 1, 1, 9, 1, 1], [0, 1, 1, 9, 1, 1]], [[9, 6, 11, 13, 10, 10, 6], [9, 6, 11, 13, 10, 10, 6]], [[8, 2, 6, 1, 5, 8], [8, 2, 6, 1, 5, 8]], [[11, 13, 5, 11, 13], [11, 13, 5, 11, 13]], [[1, 7, 1, 3, 1, 6, 7, 3, 3, 5, 7], [1, 7, 1, 3, 1, 6, 7, 3, 3, 5, 7]], [[3, 4, 13, 11, 5, 10, 11, 11], [3, 4, 13, 11, 5, 10, 11, 11]], [[11, 0, 3, 0], [11, 0, 3, 0]], [[13, 9, 4, 13], [13, 9, 4, 13]], [[9, 2, 13], [9, 2, 13]], [[3, 3, 6, 5, 13, 7, 11, 11, 6, 4], [3, 3, 6, 5, 13, 7, 11, 11, 6, 4]], [[8, 11, 10, 10, 11, 13, 8], [8, 11, 10, 10, 11, 13, 8]], [[5, 1, 3, 5, 7, 3, 2, 7, 3, 2], [5, 1, 3, 5, 7, 3, 2, 7, 3, 2]], [[2, 2, 3, 2, 2, -1, 2, 2, 2], [2, 2, 3, 2, 2, -1, 2, 2, 2]], [[4, 3, 3], [4, 3, 3]], [[2, 2, 2, 2, 2, 9, 2], [2, 2, 2, 2, 2, 9, 2]], [[3, 12, 4, 4, 13, 11, 5, 10, 11], [3, 12, 4, 4, 13, 11, 5, 10, 11]], [[13, 9, 13], [13, 9, 13]], [[11, 10, 2], [11, 10, 2]], [[-1, 2, 11, 13], [-1, 2, 11, 13]], [[2, 4, 6, 7, 2, 4, 6, 8], [2, 4, 6, 7, 2, 4, 6, 8]], [[9, 11, 10, 10, 9, 11, 13], [9, 11, 10, 10, 9, 11, 13]], [[1, 1, 11, 12, 4, 1, 1], [1, 1, 11, 12, 4, 1, 1]], [[11], [11]], [[9, 6, 11, 13, 7, 10, 9], [9, 6, 11, 13, 7, 10, 9]], [[2, 2, 5, 1, 2, 2, 2, 2, 2], [2, 2, 5, 1, 2, 2, 2, 2, 2]], [[3, 2, 0, 2, 2, 6, 2, 2, 6, 2], [3, 2, 0, 2, 2, 6, 2, 2, 6, 2]], [[5, 14, 4, 1], [5, 14, 4, 1]], [[1, 1, 1, 1, 1, 1, 1], [2, 2, 5, 2, 2, 2, 2, 2]], [[8, 1, 5, 1], [8, 1, 5, 1]], [[3, 2, 5, 2, 2, 2, 2, 2, 2], [3, 2, 5, 2, 2, 2, 2, 2, 2]], [[7, 0, 10, 5, 2, 11], [7, 0, 10, 5, 2, 11]], [[1, 5, 1, 3, 10, 6, 9, 7, 3, 5], [1, 5, 1, 3, 10, 6, 9, 7, 3, 5]], [[2, 2, 11, 4, 2, 2, 3, 2, 4], [2, 2, 11, 4, 2, 2, 3, 2, 4]], [[9, 11, 13, 11], [9, 11, 13, 11]], [[9, 0, 10, 11], [9, 0, 10, 11]], [[1, 5, 1, 3, 10, 6, 9, 7, 9, 3, 5], [1, 5, 1, 3, 10, 6, 9, 7, 9, 3, 5]], [[2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1]], [[9, 6, 11, 13, 7, 13, 10, 9], [9, 6, 11, 13, 7, 13, 10, 9]], [[5, 2, 8, 0, 8, 1, 0], [5, 2, 8, 0, 8, 1, 0]], [[11, 13, 14, 9, 9], [11, 13, 14, 9, 9]], [[10, 11, 13, 11], [10, 11, 13, 11]], [[11, 4, 6, 10, 11], [11, 4, 6, 10, 11]], [[1, 2, 1, 1, 7, 1], [1, 2, 1, 1, 7, 1]], [[2, 2, 2, -1, 2, 1, 3, 2, -1, 1], [2, 2, 2, -1, 2, 1, 3, 2, -1, 1]], [[2, 3, 7, 8, 6, 7, 13, 7, 2], [2, 3, 7, 8, 6, 7, 13, 7, 2]], [[9, 6, 0, 4, 0, 9], [9, 6, 0, 4, 0, 9]], [[2, 6, 8, 2, 10, 6, 2], [2, 6, 8, 2, 10, 6, 2]], [[1, 5, 7, 6, 1, 3, 10, 6, 1, 3, 5], [1, 5, 7, 6, 1, 3, 10, 6, 1, 3, 5]], [[8, 10, 11, 13, 8, 13], [8, 10, 11, 13, 8, 13]], [[2, 1, 2, 2, 9, 2], [2, 1, 2, 2, 9, 2]], [[9, 11, 9, 2, 13], [9, 11, 9, 2, 13]], [[5, 13, 14, 9, 14, 9], [5, 13, 14, 9, 14, 9]], [[1, 9, 11, 12, 9], [2, 4, 6, 8]], [[7, 10, 5, 2, 11], [7, 10, 5, 2, 11]], [[2, 6, 8, 2, 10, 3, 6, 8], [2, 6, 8, 2, 10, 3, 6, 8]], [[9, 5, 11], [9, 5, 11]], [[3, 14, 5, 11, 11, 13], [3, 14, 5, 11, 11, 13]], [[1, 5, 1, 3, 10, 6, 9, 4, 7, 3, 5], [1, 5, 1, 3, 10, 6, 9, 4, 7, 3, 5]], [[5, 1, 8, 1, 8, 7, 2], [5, 1, 8, 1, 8, 7, 2]], [[11, 8, 2, 13], [11, 8, 2, 13]], [[10, 9, 2, 3, 11, 9], [10, 9, 2, 3, 11, 9]], [[3, 4, 13, 8, 5, 11, 5, 3], [3, 4, 13, 8, 5, 11, 5, 3]], [[2, 2, 1, 2, 1, 2], [2, 2, 1, 2, 1, 2]], [[1, 1, 2, 1, 1], [1, 1, 2, 1, 1]], [[3, 4, 13, 11, 5, 11, 5], [3, 4, 13, 11, 5, 11, 5]], [[9, 11, 0, 0, 0], [9, 11, 0, 0, 0]], [[11, 3], [11, 3]], [[14, 2, 3, 1, 2], [14, 2, 3, 1, 2]], [[1, 1, 2, 1, 1, 1], [1, 1, 2, 1, 1, 1]], [[1, 5, 6, 1, 4, 5, 7, 3, 5, 1, 1], [1, 5, 6, 1, 4, 5, 7, 3, 5, 1, 1]], [[3, 2, 2, 2, 2, 2, 2, 8, 2, 3, 2], [3, 2, 2, 2, 2, 2, 2, 8, 2, 3, 2]], [[2, 2, 2, 1, -1, 0, 2, 1, 3, 2, -1, 8, 1], [2, 2, 2, 1, -1, 0, 2, 1, 3, 2, -1, 8, 1]], [[2, 2, 2, 2], [1, 1, 0, 1, 1]], [[8, 10, 11, 0, 13, 8], [8, 10, 11, 0, 13, 8]], [[3, 11, 13, 5, 11, 11, 13, 13], [3, 11, 13, 5, 11, 11, 13, 13]], [[-1, 1, 5, 7, 1, 3, 10, 6, 7, 3, 5, 10, 10], [-1, 1, 5, 7, 1, 3, 10, 6, 7, 3, 5, 10, 10]], [[11, 13, 5, 11, 13, 11], [11, 13, 5, 11, 13, 11]], [[9, 1, 1, 1, 11, 2, 1, 1, 11], [9, 1, 1, 1, 11, 2, 1, 1, 11]], [[1, 1, 2, 1, 2], [1, 1, 2, 1, 2]], [[0, 1, 9, 1, 1], [0, 1, 9, 1, 1]], [[1, 1, 4, 1, 1, 1, 1, 1, 1, 1], [1, 1, 4, 1, 1, 1, 1, 1, 1, 1]], [[10, 2, 11, 10, 11], [10, 2, 11, 10, 11]], [[9, 4, 11, 5, 9], [9, 4, 11, 5, 9]], [[3, 0, 11, 13, 12, 5, 11, 11, 13, 13], [3, 0, 11, 13, 12, 5, 11, 11, 13, 13]], [[2, 8, 2, 10, 3, 6, 8, 7], [2, 8, 2, 10, 3, 6, 8, 7]], [[14, 3, 12, 11, 12, 12, 12, 12], [14, 3, 12, 11, 12, 12, 12, 12]], [[12, 9, 11, 10, 9, 12], [12, 9, 11, 10, 9, 12]], [[4, 9, 11, 0, 0, 0], [4, 9, 11, 0, 0, 0]], [[8, 0, 8], [8, 0, 8]], [[2, 2, 5, 2, 2, 2, 2, 3, 1, 2], [2, 2, 5, 2, 2, 2, 2, 3, 1, 2]], [[9, 5, 11, 5, 5], [9, 5, 11, 5, 5]], [[10, 11, 13, 14, 10, 9], [10, 11, 13, 14, 10, 9]], [[8, 9, 11, 2, 11], [8, 9, 11, 2, 11]], [[1, 1, 1, 1, 7], [2, 2, 1, 2, 1, 2]], [[1, 2, 1, 7, 1], [1, 2, 1, 7, 1]], [[9, 1, 11, 11, 1, 13], [9, 1, 11, 11, 1, 13]], [[3, 2, 2, 2, 2, 2, 8, 2, 3, 2], [3, 2, 2, 2, 2, 2, 8, 2, 3, 2]], [[3, 13, 7, 11, 12, 13], [3, 13, 7, 11, 12, 13]], [[5, 2, 8, 0, 0], [5, 2, 8, 0, 0]], [[2, 4, 13, 6], [2, 4, 13, 6]], [[2, 3, 7, 8, 6, 7, 7, 2, 8], [2, 3, 7, 8, 6, 7, 7, 2, 8]], [[9, 14, 11, 13, 9], [9, 14, 11, 13, 9]], [[9, 11, 13, 2], [9, 11, 13, 2]], [[8, 14, 11, 13, 9], [8, 14, 11, 13, 9]], [[1, 5, 5], [1, 5, 5]], [[2, 2, -1, 5, 2, 2, 2, 2, 2, 2, 2], [2, 2, -1, 5, 2, 2, 2, 2, 2, 2, 2]], [[2, 2, 11, 2, 2, 2, 1, 2], [2, 2, 11, 2, 2, 2, 1, 2]], [[2, 8, 0, 8, 8], [2, 8, 0, 8, 8]], [[3, 12, 13], [3, 12, 13]], [[2, 2, 2, 2, 13, 2], [2, 2, 2, 2, 13, 2]], [[13, 11, 13, 13], [13, 11, 13, 13]], [[9, 10, 5, 12, 11, 10, 10, 10], [9, 10, 5, 12, 11, 10, 10, 10]], [[14, 2, 3, 1], [14, 2, 3, 1]], [[2, 8, 2, 10, 3, 6, 8, 7, 7], [2, 8, 2, 10, 3, 6, 8, 7, 7]], [[3, 2, 2, 2, 2, 2, 2, 3, 2, 2], [3, 2, 2, 2, 2, 2, 2, 3, 2, 2]], [[3, 2, 2, 2, 2, 1, 3, 2], [3, 2, 2, 2, 2, 1, 3, 2]], [[2, 2, 9, 0, 2, -1, 14], [2, 2, 9, 0, 2, -1, 14]], [[3, 4, 13, 3, 6, 10, 5, 11, 5, 3], [3, 4, 13, 3, 6, 10, 5, 11, 5, 3]], [[5, 2, 0, 1, 5, 1], [5, 2, 0, 1, 5, 1]], [[-1, 5, 2, 8, 1, 5], [-1, 5, 2, 8, 1, 5]], [[12, 9, 11, 10, 4, 9, 12], [12, 9, 11, 10, 4, 9, 12]], [[1, 7, 1, 3, 1, 6, 7, 3, 3, 5, 7, 7], [1, 7, 1, 3, 1, 6, 7, 3, 3, 5, 7, 7]], [[9, 12, 11, 12, 11, 9], [9, 12, 11, 12, 11, 9]], [[10, 11, 1], [10, 11, 1]], [[1, 1, 1, 1, 2, 1], [1, 1, 1, 1, 2, 1]], [[3, 13, 7, 11, 12, 13, 11], [3, 13, 7, 11, 12, 13, 11]], [[-1, 4, 6, 8, 8, 7], [-1, 4, 6, 8, 8, 7]], [[3, 0, 11, 13, 12, 5, 11, 11, 13, 13, 11], [3, 0, 11, 13, 12, 5, 11, 11, 13, 13, 11]], [[1, 7], [1, 7]], [[1, 1, 2, 7, 1], [1, 1, 2, 7, 1]], [[11, 13, 9, 9], [11, 13, 9, 9]], [[1, 1, 2, 1, 1, 7], [2, 2, 1, 2, 1, 2]], [[9, 8, 11, 13, 9], [9, 8, 11, 13, 9]], [[2, 2, 5, 1, 2, 2, 2, 2, 3, 2], [2, 2, 5, 1, 2, 2, 2, 2, 3, 2]], [[2, 2, 2, 3, 2, 3, 2, 2], [2, 2, 2, 3, 2, 3, 2, 2]], [[8, -1, 8, 8], [8, -1, 8, 8]], [[2, 2, 2, 2, 3, 3, 2, 2], [2, 2, 2, 2, 3, 3, 2, 2]], [[12, 9, 11, 10, 13, 8], [12, 9, 11, 10, 13, 8]], [[1, 0, 1, 1, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1]], [[10, 10, 9], [10, 10, 9]], [[-1, 4, 0, 6, 8, 8, 7], [-1, 4, 0, 6, 8, 8, 7]], [[0, 1, 9, 1], [0, 1, 9, 1]], [[9, 11, 2, 14, 14], [9, 11, 2, 14, 14]], [[1, 2, 1, 1, 7, 1, 1], [1, 2, 1, 1, 7, 1, 1]], [[1, 1, 12], [2, 2, 1, 2]], [[5, 2, 11, 13], [5, 2, 11, 13]]]\n    results = ['YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO']\n    for i, (inp, exp) in enumerate(zip(inputs, results)):\n        assertion(candidate(*inp), exp, 0)\n",
      "entry_point": "exchange",
      "complete_code": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n"
    },
    "execution_info": {
      "max_mutations_per_operator": 10,
      "total_operators_tested": 46,
      "operators_with_mutations": 10,
      "execution_timestamp": "2025-08-01T15:53:21.085976"
    }
  }
}