{
  "timestamp": "20250801_153512",
  "test_type": "mutation_testing",
  "metadata": {
    "task_id": "HumanEval/1",
    "timestamp": "20250801_153512",
    "tester_version": "1.0",
    "total_operators_tested": 10,
    "operators_with_errors": 0
  },
  "summary": {
    "original_passes": true,
    "total_mutations": 31,
    "killed_mutations": 29,
    "mutation_score": 0.9354838709677419,
    "survival_rate": 0.06451612903225812
  },
  "detailed_results": {
    "task_id": "HumanEval/1",
    "dataset_type": "plus",
    "original_passes": true,
    "total_mutations": 31,
    "killed_mutations": 29,
    "mutation_score": 0.9354838709677419,
    "mutation_results": {
      "NumberReplacer": {
        "total_mutations": 8,
        "killed_mutations": 8,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (1, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (1, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpel09462r.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpel09462r.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpel09462r.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:05.780606",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (-1, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (-1, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp1dedbw97.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1dedbw97.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1dedbw97.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:05.985172",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 2\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 2\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpfvoe2frc.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvoe2frc.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvoe2frc.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:06.190109",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 0\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 0\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpn53b_ecn.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn53b_ecn.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn53b_ecn.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:06.398375",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 2\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 2\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp3i1fgoab.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3i1fgoab.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3i1fgoab.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:06.635251",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 5,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 0\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 0\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp9rg02oiu.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9rg02oiu.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9rg02oiu.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:06.897409",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 6,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 1:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 1:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmph0clyct_.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph0clyct_.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph0clyct_.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:07.087171",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 7,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == -1:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == -1:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpfubtfxq4.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfubtfxq4.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfubtfxq4.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:07.266414",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 8,
        "mutations_tested": 8
      },
      "AddEq->SubEq": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt -= 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt -= 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpv1dqax8t.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv1dqax8t.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv1dqax8t.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:07.474278",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group -= ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group -= ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp92wl280p.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp92wl280p.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n              ~~~~~~~~~^^^^^^\n  File \"/tmp/tmp92wl280p.py\", line 29, in separate_paren_groups\n    group -= ch\nTypeError: unsupported operand type(s) for -=: 'str' and 'str'\n",
            "timestamp": "2025-08-01T15:35:07.674539",
            "status": "BROKEN",
            "reason": "code_error"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "SubEq->AddEq": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt += 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt += 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp329pd62p.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp329pd62p.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp329pd62p.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:07.859535",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Eq->NotEq": {
        "total_mutations": 3,
        "killed_mutations": 3,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch != '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch != '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpohabycjj.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpohabycjj.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpohabycjj.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:08.074183",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch != ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch != ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp68zuy7ld.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp68zuy7ld.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp68zuy7ld.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:08.273104",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt != 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt != 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp169uqjl8.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp169uqjl8.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp169uqjl8.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:08.431433",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 3,
        "mutations_tested": 3
      },
      "NotEq->Eq": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch == ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch == ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpeb1_250x.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeb1_250x.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeb1_250x.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:08.584627",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group == '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group == '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpqsyhojpk.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqsyhojpk.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqsyhojpk.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:08.804726",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "Remove ReturnValue": {
        "total_mutations": 1,
        "killed_mutations": 1,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpq8c62yb_.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpq8c62yb_.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpq8c62yb_.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:09.036487",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 1,
        "mutations_tested": 1
      },
      "Zero->One": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (1, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (1, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmptd7w3sug.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptd7w3sug.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptd7w3sug.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:09.223370",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 1:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 1:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpmftdxklg.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmftdxklg.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmftdxklg.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:09.413398",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "One->Zero": {
        "total_mutations": 2,
        "killed_mutations": 2,
        "survival_rate": 0.0,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 0\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 0\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpljpade1o.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpljpade1o.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpljpade1o.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:09.599276",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 0\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 0\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmps3o6w3ay.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps3o6w3ay.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps3o6w3ay.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:09.767883",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 2,
        "mutations_tested": 2
      },
      "String->Empty": {
        "total_mutations": 4,
        "killed_mutations": 3,
        "survival_rate": 0.25,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:09.967877",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpx15k_zs4.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx15k_zs4.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx15k_zs4.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:10.148255",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == '':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == '':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpnf4x7isi.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnf4x7isi.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnf4x7isi.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:10.391378",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != '':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != '':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp435n4vv1.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp435n4vv1.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp435n4vv1.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:10.649453",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 4,
        "mutations_tested": 4
      },
      "String->X": {
        "total_mutations": 7,
        "killed_mutations": 6,
        "survival_rate": 0.14285714285714285,
        "detailed_mutations": [
          {
            "mutation_index": 0,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"X\"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"X\"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": true,
            "execution_output": "All tests passed!\n",
            "timestamp": "2025-08-01T15:35:10.844146",
            "status": "SURVIVED",
            "reason": "tests_passed"
          },
          {
            "mutation_index": 1,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, 'X', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, 'X', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpz_y93i0j.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpz_y93i0j.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpz_y93i0j.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:11.025886",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 2,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == 'X':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == 'X':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpi_kze95e.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpi_kze95e.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpi_kze95e.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:11.201235",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 3,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == 'X':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == 'X':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp8yo3nz09.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8yo3nz09.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8yo3nz09.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:11.410318",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 4,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != 'X':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != 'X':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp7oeywj1s.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7oeywj1s.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7oeywj1s.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:11.622074",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 5,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != 'X':\n                results.append(group)\n            group = ''\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != 'X':\n                results.append(group)\n            group = ''\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmpdcibr55_.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdcibr55_.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdcibr55_.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:11.891837",
            "status": "KILLED",
            "reason": "test_failure"
          },
          {
            "mutation_index": 6,
            "original_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
            "mutated_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = 'X'\n    return results",
            "mutated_complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    cnt, group, results = (0, '', [])\n    for ch in paren_string:\n        if ch == '(':\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ':\n            group += ch\n        if cnt == 0:\n            if group != '':\n                results.append(group)\n            group = 'X'\n    return results",
            "execution_success": false,
            "execution_output": "Traceback (most recent call last):\n  File \"/tmp/tmp2rkz4o0e.py\", line 72, in <module>\n    check(separate_paren_groups)\n    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2rkz4o0e.py\", line 66, in check\n    assertion(candidate(*inp), exp, 0)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2rkz4o0e.py\", line 59, in assertion\n    assert exact_match\n           ^^^^^^^^^^^\nAssertionError\n",
            "timestamp": "2025-08-01T15:35:12.105018",
            "status": "KILLED",
            "reason": "test_failure"
          }
        ],
        "mutation_count_available": 7,
        "mutations_tested": 7
      }
    },
    "problem_info": {
      "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
      "canonical_solution": "\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n",
      "test_code": "\n\nimport numpy as np\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\ndef assertion(out, exp, atol):\n    exact_match = out == exp\n\n    if atol == 0 and is_floats(exp):\n        atol = 1e-6\n    if not exact_match and atol != 0:\n        assert np.allclose(out, exp, rtol=1e-07, atol=atol)\n    else:\n        assert exact_match\n\n\ndef check(candidate):\n    inputs = [['(()()) ((())) () ((())()())'], ['() (()) ((())) (((())))'], ['(()(())((())))'], ['( ) (( )) (( )( ))'], ['()'], ['(())'], ['((()))()'], ['()()()'], ['()(()())()'], ['(((()()((())))))'], ['((()()))(())'], ['()(()()((())))'], ['()()()(((()())))()(())'], ['(((())))()((()()))'], ['(((())))()(((())))()((()()))((()()))'], ['((((((())))()(((())))()((()()))((()())))()))(())'], ['()(()())()(()()((())))()'], ['()(()()((()))(((()()((()))))))'], ['()()((((()()((()))))))'], ['()()((((()()((()))))()()()))'], ['()()()(((()())))()((()))'], ['((()()((((((())))()(((())))()((()()))((()())))()))(())))(())'], ['()()()(()()()(((()())))()((()))((()())))()(())'], ['()()(()())()(()())()'], ['(((()))())()((()()))'], ['()()(()())()(()()((()))())()'], ['()()((((()()((()))))))()(()())()(()()((())))()'], ['()()(((((()()((()))))))()(()())()(()))()'], ['((() ((()()((((((  )))))))()()))) (()(()))()(()())'], ['((( ) ((( )) () (( ))))) (((( )))) (( ))'], ['(()) (()) ((() ((())))()) ((())(()))()'], ['((()) ()) ()(()) (()(())())'], ['((()) (())() (())(()))()(((())))((()()))((()))'], ['(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())))'], ['(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())))()()()()()'], ['()()()()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()'], ['() ( ) (( )) ((( )))()(()()()) ((()())())() (()()()()()())'], ['((( ) (((()) (()) ((() ((())))()) ((())(()))()( )) () (( ))))) (((( )))) (( ))'], ['(()()()()()())'], ['(()) (()) '], ['((( ) (((())) (()) ((() ((())((((((() ((() ((() ())))))))))))()) ((())(()))()( )) () (( ))))) (((( )))) (( ))'], ['(()) ((((() ((()()((((((  )))))))()()))) (()(()))()(()()))) '], ['((( ) (((()(())())) (()) ((() ((())((((((() ((() ((() ())))))))))))()) ((())(()))()( )) () (( ))))) (((( )))) (( ))'], ['()(())'], ['(())()'], ['(()(()))'], ['((( ) (((()(())()) (()) ((() ((())((((((() ((() ((() ())))))))))))()) ((())(()))()( )) (())(()))()((((()))((())))((()()))((())))() (( ))))) (((( )))) (( ))'], ['(())(())'], [' (()) (()) ((() ((())))()) ((())(()))()'], ['((())(()))()'], ['()((()()()()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()))'], ['(()(())())'], [''], ['((( ) )(((())) (()(())(( ))))) (((( )))) (( ))'], ['((()) ()) ()(( )) (()(())())'], ['(()()()())'], ['()(()())()(())'], ['()()()()()()((()))()()()((()))()()(())'], ['(()(()))()(()())'], ['((()())())()'], ['((( ) (((()) (()) ((() ((()))))()) (()()()()()())((())(()))()( )) () (( ())))) (((( )))) (( ))'], ['((( )) ()) ()(()) (()(())())'], ['((((((()) ((() ((() ())))))))))'], ['(((()) ()) ())'], ['(())((()(((())))((()()))(((((()) (())() (())(())((())((( ) (((()) (()) ((() ((())))()) (()()()()()())((())(()))()( )) () (( ())))) (((( )))) (( )))))()))((())))))'], ['( ) (( )) (( )( ))       ()()()'], ['(())(()())()((((((()))))))'], ['( )'], ['((()))'], ['((( ) ((( )) () (( )))))  (((( )))) (( ))'], ['((( ) ((( )((( ) ((( )) () (( ))))) (((( )))) (( ))) () (( ))))) (((( )))) (( ))'], ['() ( ) (( )) ((( )))()(()()()) ((()())())()(()()()()()())'], ['(((())))(((())))(((())))(((())))(((())))(((())))(((())))(((())()(())))(((())))(((())))()()()()()'], ['((()())())()(()()()()()())'], ['((()))(()()())'], ['((( ))) (( ))'], ['(((())))'], ['((() ((()()))))()(()()())()(()())'], ['(((((((() (((()()))))))))))'], ['((()))()(())'], ['()()()()()()((()))()()()((()))()()()((()))()()()((()))()()()'], ['(()())()'], ['((())(()(()(()))()(()())()()((()))()()()((()))()))()'], ['((( ) ((( )) () (( ))))) (((( )) )) (( ))'], ['((()())())()(()(((()())()(()()))()(()())()()((())))()()()((())())()()()())'], ['(((()())))'], ['(())()()()((()))()()()']]\n    results = [['(()())', '((()))', '()', '((())()())'], ['()', '(())', '((()))', '(((())))'], ['(()(())((())))'], ['()', '(())', '(()())'], ['()'], ['(())'], ['((()))', '()'], ['()', '()', '()'], ['()', '(()())', '()'], ['(((()()((())))))'], ['((()()))', '(())'], ['()', '(()()((())))'], ['()', '()', '()', '(((()())))', '()', '(())'], ['(((())))', '()', '((()()))'], ['(((())))', '()', '(((())))', '()', '((()()))', '((()()))'], ['((((((())))()(((())))()((()()))((()())))()))', '(())'], ['()', '(()())', '()', '(()()((())))', '()'], ['()', '(()()((()))(((()()((()))))))'], ['()', '()', '((((()()((()))))))'], ['()', '()', '((((()()((()))))()()()))'], ['()', '()', '()', '(((()())))', '()', '((()))'], ['((()()((((((())))()(((())))()((()()))((()())))()))(())))', '(())'], ['()', '()', '()', '(()()()(((()())))()((()))((()())))', '()', '(())'], ['()', '()', '(()())', '()', '(()())', '()'], ['(((()))())', '()', '((()()))'], ['()', '()', '(()())', '()', '(()()((()))())', '()'], ['()', '()', '((((()()((()))))))', '()', '(()())', '()', '(()()((())))', '()'], ['()', '()', '(((((()()((()))))))()(()())()(()))', '()'], ['((()((()()(((((()))))))()())))', '(()(()))', '()', '(()())'], ['((()((())()(()))))', '(((())))', '(())'], ['(())', '(())', '((()((())))())', '((())(()))', '()'], ['((())())', '()', '(())', '(()(())())'], ['((())(())()(())(()))', '()', '(((())))', '((()()))', '((()))'], ['(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))'], ['(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '()', '()', '()', '()', '()'], ['()', '()', '()', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()'], ['()', '()', '(())', '((()))', '()', '(()()())', '((()())())', '()', '(()()()()()())'], ['((()(((())(())((()((())))())((())(()))()())()(()))))', '(((())))', '(())'], ['(()()()()()())'], ['(())', '(())'], ['((()(((()))(())((()((())((((((()((()((()())))))))))))())((())(()))()())()(()))))', '(((())))', '(())'], ['(())', '((((()((()()(((((()))))))()())))(()(()))()(()())))'], ['((()(((()(())()))(())((()((())((((((()((()((()())))))))))))())((())(()))()())()(()))))', '(((())))', '(())'], ['()', '(())'], ['(())', '()'], ['(()(()))'], ['((()(((()(())())(())((()((())((((((()((()((()())))))))))))())((())(()))()())(())(()))()((((()))((())))((()()))((())))()(()))))', '(((())))', '(())'], ['(())', '(())'], ['(())', '(())', '((()((())))())', '((())(()))', '()'], ['((())(()))', '()'], ['()', '((()()()()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()((()))()()()))'], ['(()(())())'], [], ['((())(((()))(()(())(()))))', '(((())))', '(())'], ['((())())', '()', '(())', '(()(())())'], ['(()()()())'], ['()', '(()())', '()', '(())'], ['()', '()', '()', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '(())'], ['(()(()))', '()', '(()())'], ['((()())())', '()'], ['((()(((())(())((()((()))))())(()()()()()())((())(()))()())()((()))))', '(((())))', '(())'], ['((())())', '()', '(())', '(()(())())'], ['((((((())((()((()())))))))))'], ['(((())())())'], ['(())', '((()(((())))((()()))(((((())(())()(())(())((())((()(((())(())((()((())))())(()()()()()())((())(()))()())()((()))))(((())))(()))))()))((())))))'], ['()', '(())', '(()())', '()', '()', '()'], ['(())', '(()())', '()', '((((((()))))))'], ['()'], ['((()))'], ['((()((())()(()))))', '(((())))', '(())'], ['((()((()((()((())()(()))))(((())))(()))()(()))))', '(((())))', '(())'], ['()', '()', '(())', '((()))', '()', '(()()())', '((()())())', '()', '(()()()()()())'], ['(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())))', '(((())()(())))', '(((())))', '(((())))', '()', '()', '()', '()', '()'], ['((()())())', '()', '(()()()()()())'], ['((()))', '(()()())'], ['((()))', '(())'], ['(((())))'], ['((()((()()))))', '()', '(()()())', '()', '(()())'], ['(((((((()(((()()))))))))))'], ['((()))', '()', '(())'], ['()', '()', '()', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()', '((()))', '()', '()', '()'], ['(()())', '()'], ['((())(()(()(()))()(()())()()((()))()()()((()))()))', '()'], ['((()((())()(()))))', '(((())))', '(())'], ['((()())())', '()', '(()(((()())()(()()))()(()())()()((())))()()()((())())()()()())'], ['(((()())))'], ['(())', '()', '()', '()', '((()))', '()', '()', '()']]\n    for i, (inp, exp) in enumerate(zip(inputs, results)):\n        assertion(candidate(*inp), exp, 0)\n",
      "entry_point": "separate_paren_groups",
      "complete_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n"
    },
    "execution_info": {
      "max_mutations_per_operator": 10,
      "total_operators_tested": 46,
      "operators_with_mutations": 10,
      "execution_timestamp": "2025-08-01T15:35:12.108183"
    }
  }
}